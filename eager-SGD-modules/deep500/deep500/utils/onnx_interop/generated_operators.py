### THIS FILE IS AUTOMATICALLY GENERATED BY generate_operators.py, DO NOT MODIFY
from deep500.utils.onnx_interop.onnx_objects import OnnxAttribute, Operation


class Sin(Operation):
    """
Calculates the sine of the given input tensor, element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Sin, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_input = self.input[0]
        # The sine of the input tensor computed element-wise
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Sin, self).accept(visitor, network)
        visitor.visit_sin(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Atan(Operation):
    """
Calculates the arctangent (inverse of tangent) of the given input tensor, element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Atan, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_input = self.input[0]
        # The arctangent of the input tensor computed element-wise
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Atan, self).accept(visitor, network)
        visitor.visit_atan(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Asin(Operation):
    """
Calculates the arcsine (inverse of sine) of the given input tensor, element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Asin, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_input = self.input[0]
        # The arcsine of the input tensor computed element-wise
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Asin, self).accept(visitor, network)
        visitor.visit_asin(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Acos(Operation):
    """
Calculates the arccosine (inverse of cosine) of the given input tensor, element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Acos, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_input = self.input[0]
        # The arccosine of the input tensor computed element-wise
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Acos, self).accept(visitor, network)
        visitor.visit_acos(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Unsqueeze(Operation):
    """
Insert single-dimensional entries to the shape of a tensor.
Takes one required argument `axes`, a list of dimensions that will be inserted.
Dimension indices in `axes` are as seen in the output tensor. For example:
  Given a tensor such that tensor with shape [3, 4, 5], then
  Unsqueeze(tensor, axes=[0, 4]) has shape [1, 3, 4, 5, 1]
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Unsqueeze, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        # Original tensor
        self.i_data = self.input[0]
        # Reshaped tensor with same data as input.
        self.o_expanded = self.output[0]

    def accept(self, visitor, network):
        super(Unsqueeze, self).accept(visitor, network)
        visitor.visit_unsqueeze(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_expanded: str, axes: OnnxAttribute):
        attributes = {
            'axes': axes,
        }
        return cls([i_data], [o_expanded], None, None, None, attributes, None)


class TopK(Operation):
    """
Retrieve the top-K elements along a specified axis. Given an input tensor of
shape [a_1, a_2, ..., a_n, r] and integer argument k, return two outputs:
  -Value tensor of shape [a_1, a_2, ..., a_{axis-1}, k, a_{axis+1}, ... a_n]
    which contains the values of the top k elements along the specified axis
  -Index tensor of shape [a_1, a_2, ..., a_{axis-1}, k, a_{axis+1}, ... a_n] which
   contains the indices of the top k elements (original indices from the input
   tensor).

Given two equivalent values, this operator uses the indices along the axis  as
 a tiebreaker. That is, the element with the lower index will appear first.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(TopK, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        self.k = self.attributes.get('k')
        # Tensor of shape [a_1, a_2, ..., a_n, r]
        self.i_X = self.input[0]
        # Tensor of shape [a_1, a_2, ..., a_{axis-1}, k, a_{axis+1}, ... a_n] containing top K values from the input tensor
        self.o_Values = self.output[0]
        # Tensor of shape [a_1, a_2, ..., a_{axis-1}, k, a_{axis+1}, ... a_n] containing the corresponding input tensor indices for the top K values.
        self.o_Indices = self.output[1]

    def accept(self, visitor, network):
        super(TopK, self).accept(visitor, network)
        visitor.visit_topk(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Values: str, o_Indices: str, axis: OnnxAttribute, k: OnnxAttribute):
        attributes = {
            'axis': axis,
            'k': k,
        }
        return cls([i_X], [o_Values, o_Indices], None, None, None, attributes, None)


class Tile(Operation):
    """Constructs a tensor by tiling a given tensor.
This is the same as function `tile` in Numpy, but no broadcast.
For example A = [[1, 2], [3, 4]], B = [1, 2], tile(A, B) = [[1, 2, 1, 2], [3, 4, 3, 4]]
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Tile, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor of any shape.
        self.i_input = self.input[0]
        # 1D int64 tensor of the same length as input's dimension number, includes numbers of repeated copies along input's dimensions.
        self.i_repeats = self.input[1]
        # Output tensor of the same dimension and type as tensor input. output_dim[i] = input_dim[i] * repeats[i]
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Tile, self).accept(visitor, network)
        visitor.visit_tile(self, network)

    @classmethod
    def create_op(cls, i_input: str, i_repeats: str, o_output: str):
        attributes = {
        }
        return cls([i_input, i_repeats], [o_output], None, None, None, attributes, None)


class ThresholdedRelu(Operation):
    """
ThresholdedRelu takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the rectified linear function, y = x for x > alpha, y = 0 otherwise,
is applied to the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ThresholdedRelu, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.alpha = self.attributes.get('alpha')
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(ThresholdedRelu, self).accept(visitor, network)
        visitor.visit_thresholdedrelu(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, alpha: OnnxAttribute):
        attributes = {
            'alpha': alpha,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Tanh(Operation):
    """
Calculates the hyperbolic tangent of the given input tensor element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Tanh, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_input = self.input[0]
        # The hyperbolic tangent values of the input tensor computed element-wise
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Tanh, self).accept(visitor, network)
        visitor.visit_tanh(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Sum(Operation):
    """
Element-wise sum of each of the input tensors. All inputs and outputs must
have the same shape and data type.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Sum, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # List of tensors for Sum.
        # input is variadic [1,infty) just use self.input to access whole list
        # Output tensor. Same dimension as inputs.
        self.o_sum = self.output[0]

    def accept(self, visitor, network):
        super(Sum, self).accept(visitor, network)
        visitor.visit_sum(self, network)

    @classmethod
    def create_op(cls, i_data_0: str, o_sum: str):
        attributes = {
        }
        return cls([i_data_0], [o_sum], None, None, None, attributes, None)


class Squeeze(Operation):
    """
Remove single-dimensional entries from the shape of a tensor.
Takes a  parameter `axes` with a list of axes to squeeze.
If an axis is selected with shape entry not equal to one, an error is raised.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Squeeze, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        # Tensors with at least max(dims) dimensions.
        self.i_data = self.input[0]
        # Reshaped tensor with same data as input.
        self.o_squeezed = self.output[0]

    def accept(self, visitor, network):
        super(Squeeze, self).accept(visitor, network)
        visitor.visit_squeeze(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_squeezed: str, axes: OnnxAttribute):
        attributes = {
            'axes': axes,
        }
        return cls([i_data], [o_squeezed], None, None, None, attributes, None)


class SpaceToDepth(Operation):
    """SpaceToDepth rearranges blocks of spatial data into depth. More specifically,
this op outputs a copy of the input tensor where values from the height and width dimensions
are moved to the depth dimension.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(SpaceToDepth, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.blocksize = self.attributes.get('blocksize')
        # Input tensor of [N,C,H,W], where N is the batch axis, C is the channel or depth, H is the height and W is the width.
        self.i_input = self.input[0]
        # Output tensor of [N, C * blocksize * blocksize, H/blocksize, W/blocksize].
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(SpaceToDepth, self).accept(visitor, network)
        visitor.visit_spacetodepth(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, blocksize: OnnxAttribute):
        attributes = {
            'blocksize': blocksize,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Softmax(Operation):
    """
The operator computes the softmax (normalized exponential) values for each layer in the batch
 of the given input. The input is a 2-D tensor (Tensor<float>) of size
(batch_size x input_feature_dimensions). The output tensor has the same shape
and contains the softmax values of the corresponding input.

X does not need to explicitly be a 2D vector; rather, it will be
coerced into one. For an arbitrary n-dimensional tensor
X \in [a_0, a_1, ..., a_{k-1}, a_k, ..., a_{n-1}] and k is
the axis provided, then X will be coerced into a 2-dimensional tensor with
dimensions [a_0 * ... * a_{k-1}, a_k * ... * a_{n-1}]. For the default
case where axis=1, this means the X tensor will be coerced into a 2D tensor
of dimensions [a_0, a_1 * ... * a_{n-1}], where a_0 is often the batch size.
In this situation, we must have a_0 = N and a_1 * ... * a_{n-1} = D.
Each of these dimensions must be matched correctly, or else the operator
will throw errors.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Softmax, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        # The input tensor that's coerced into a 2D matrix of size (NxD) as described above.
        self.i_input = self.input[0]
        # The output values with the same shape as input tensor.
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Softmax, self).accept(visitor, network)
        visitor.visit_softmax(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, axis: OnnxAttribute):
        attributes = {
            'axis': axis,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Slice(Operation):
    """
Produces a slice of the input tensor along multiple axes. Similar to numpy:
https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html
Slices uses `axes`, `starts` and `ends` attributes to specify the start and end
dimension for each axis in the list of axes, it uses this information to
slice the input `data` tensor. If a negative value is passed for any of the
start or end indices, it represent number of elements before the end of that
dimension. If the value passed to start or end is larger than the `n` (the
number of elements in this dimension), it represents `n`. For slicing to the
end of a dimension with unknown size, it is recommended to pass in `INT_MAX`.
If `axes` are omitted, they are set to `[0, ..., ndim-1]`.
Example 1:
  data = [
      [1, 2, 3, 4],
      [5, 6, 7, 8],
  ]
  axes = [0, 1]
  starts = [1, 0]
  ends = [2, 3]
  result = [
      [5, 6, 7],
  ]
Example 2:
  data = [
      [1, 2, 3, 4],
      [5, 6, 7, 8],
  ]
  starts = [0, 1]
  ends = [-1, 1000]
  result = [
      [2, 3, 4],
  ]
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Slice, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        self.ends = self.attributes.get('ends')
        self.starts = self.attributes.get('starts')
        # Tensor of data to extract slices from.
        self.i_data = self.input[0]
        # Sliced data tensor.
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Slice, self).accept(visitor, network)
        visitor.visit_slice(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_output: str, axes: OnnxAttribute, ends: OnnxAttribute, starts: OnnxAttribute):
        attributes = {
            'axes': axes,
            'ends': ends,
            'starts': starts,
        }
        return cls([i_data], [o_output], None, None, None, attributes, None)


class Size(Operation):
    """
Takes a tensor as input and outputs a int64 scalar that equals to the total number of elements of the input tensor.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Size, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # An input tensor.
        self.i_data = self.input[0]
        # Total number of elements of the input tensor
        self.o_size = self.output[0]

    def accept(self, visitor, network):
        super(Size, self).accept(visitor, network)
        visitor.visit_size(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_size: str):
        attributes = {
        }
        return cls([i_data], [o_size], None, None, None, attributes, None)


class Shape(Operation):
    """
Takes a tensor as input and outputs an 1D int64 tensor containing the shape of the input tensor.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Shape, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # An input tensor.
        self.i_data = self.input[0]
        # Shape of the input tensor
        self.o_shape = self.output[0]

    def accept(self, visitor, network):
        super(Shape, self).accept(visitor, network)
        visitor.visit_shape(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_shape: str):
        attributes = {
        }
        return cls([i_data], [o_shape], None, None, None, attributes, None)


class Selu(Operation):
    """
Selu takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the scaled exponential linear unit function,
`y = gamma * (alpha * e^x - alpha) for x <= 0`, `y = gamma * x for x > 0`,
is applied to the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Selu, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.alpha = self.attributes.get('alpha')
        self.gamma = self.attributes.get('gamma')
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Selu, self).accept(visitor, network)
        visitor.visit_selu(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, alpha: OnnxAttribute, gamma: OnnxAttribute):
        attributes = {
            'alpha': alpha,
            'gamma': gamma,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Transpose(Operation):
    """
Transpose the input tensor similar to numpy.transpose. For example, when
perm=(1, 0, 2), given an input tensor of shape (1, 2, 3), the output shape
will be (2, 1, 3).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Transpose, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.perm = self.attributes.get('perm')
        # An input tensor.
        self.i_data = self.input[0]
        # Transposed output.
        self.o_transposed = self.output[0]

    def accept(self, visitor, network):
        super(Transpose, self).accept(visitor, network)
        visitor.visit_transpose(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_transposed: str, perm: OnnxAttribute):
        attributes = {
            'perm': perm,
        }
        return cls([i_data], [o_transposed], None, None, None, attributes, None)


class ScaledTanh(Operation):
    """
Calculates the scaled hyperbolic tangent of the given input tensor element-wise,
alpha * tanh(beta * x). This operation can be done in an in-place fashion too,
by providing the same input and output blobs.
        """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ScaledTanh, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.alpha = self.attributes.get('alpha')
        self.beta = self.attributes.get('beta')
        # Input tensor
        self.i_input = self.input[0]
        # The scaled hyperbolic tangent values of the input tensor computed element-wise
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(ScaledTanh, self).accept(visitor, network)
        visitor.visit_scaledtanh(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, alpha: OnnxAttribute, beta: OnnxAttribute):
        attributes = {
            'alpha': alpha,
            'beta': beta,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Sigmoid(Operation):
    """
Sigmoid takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the sigmoid function, y = 1 / (1 + exp(-x)), is applied to the
tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Sigmoid, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Sigmoid, self).accept(visitor, network)
        visitor.visit_sigmoid(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Scale(Operation):
    """
Scale takes one input data (Tensor<float>) and produces one output data
(Tensor<float>) whose value is the input data tensor scaled element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Scale, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.scale = self.attributes.get('scale')
        # Input data to be scaled
        self.i_input = self.input[0]
        # Output data after scaling
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Scale, self).accept(visitor, network)
        visitor.visit_scale(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, scale: OnnxAttribute):
        attributes = {
            'scale': scale,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class ReduceSumSquare(Operation):
    """
Computes the sum square of the input tensor's element along the provided axes. The resulted
tensor has the same rank as the input if keepdims equal 1. If keepdims equal 0, then
the resulted tensor have the reduced dimension pruned.

The above behavior is similar to numpy, with the exception that numpy default keepdims to
False instead of True.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ReduceSumSquare, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ReduceSumSquare, self).accept(visitor, network)
        visitor.visit_reducesumsquare(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axes: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axes': axes,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class ReduceSum(Operation):
    """
Computes the sum of the input tensor's element along the provided axes. The resulted
tensor has the same rank as the input if keepdims equal 1. If keepdims equal 0, then
the resulted tensor have the reduced dimension pruned.

The above behavior is similar to numpy, with the exception that numpy default keepdims to
False instead of True.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ReduceSum, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ReduceSum, self).accept(visitor, network)
        visitor.visit_reducesum(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axes: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axes': axes,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class Reshape(Operation):
    """
Reshape the input tensor similar to numpy.reshape.
First input is the data tensor, second input is a shape tensor which specifies the output shape. It outputs the reshaped tensor.
At most one dimension of the new shape can be -1. In this case, the value is
inferred from the size of the tensor and the remaining dimensions. A dimension
could also be 0, in which case the actual dimension value is unchanged (i.e. taken
from the input tensor).    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Reshape, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # An input tensor.
        self.i_data = self.input[0]
        # Specified shape for output.
        self.i_shape = self.input[1]
        # Reshaped data.
        self.o_reshaped = self.output[0]

    def accept(self, visitor, network):
        super(Reshape, self).accept(visitor, network)
        visitor.visit_reshape(self, network)

    @classmethod
    def create_op(cls, i_data: str, i_shape: str, o_reshaped: str):
        attributes = {
        }
        return cls([i_data, i_shape], [o_reshaped], None, None, None, attributes, None)


class ReduceProd(Operation):
    """
Computes the product of the input tensor's element along the provided axes. The resulted
tensor has the same rank as the input if keepdims equal 1. If keepdims equal 0, then
the resulted tensor have the reduced dimension pruned.

The above behavior is similar to numpy, with the exception that numpy default keepdims to
False instead of True.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ReduceProd, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ReduceProd, self).accept(visitor, network)
        visitor.visit_reduceprod(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axes: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axes': axes,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class Tan(Operation):
    """
Calculates the tangent of the given input tensor, element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Tan, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_input = self.input[0]
        # The tangent of the input tensor computed element-wise
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Tan, self).accept(visitor, network)
        visitor.visit_tan(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class GlobalAveragePool(Operation):
    """
 GlobalAveragePool consumes an input tensor X and applies average pooling across the
 the values in the same channel. This is equivalent to AveragePool with kernel size
 equal to the spatial dimension of input tensor.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(GlobalAveragePool, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size.
        self.i_X = self.input[0]
        # Output data tensor from pooling across the input tensor. Dimensions will be N x C x 1 x 1
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(GlobalAveragePool, self).accept(visitor, network)
        visitor.visit_globalaveragepool(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class ReduceL2(Operation):
    """
Computes the L2 norm of the input tensor's element along the provided axes. The resulted
tensor has the same rank as the input if keepdims equal 1. If keepdims equal 0, then
the resulted tensor have the reduced dimension pruned.

The above behavior is similar to numpy, with the exception that numpy default keepdims to
False instead of True.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ReduceL2, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ReduceL2, self).accept(visitor, network)
        visitor.visit_reducel2(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axes: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axes': axes,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class MeanVarianceNormalization(Operation):
    """Perform mean variance normalization.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(MeanVarianceNormalization, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.across_channels = self.attributes.get('across_channels')
        self.normalize_variance = self.attributes.get('normalize_variance')
        # Input tensor of shape [N,C,H,W]
        self.i_input = self.input[0]
        # Result, has same shape and type as input
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(MeanVarianceNormalization, self).accept(visitor, network)
        visitor.visit_meanvariancenormalization(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, across_channels: OnnxAttribute, normalize_variance: OnnxAttribute):
        attributes = {
            'across_channels': across_channels,
            'normalize_variance': normalize_variance,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class GRU(Operation):
    """
Computes an one-layer GRU. This operator is usually supported via some custom
implementation such as CuDNN.

Notations:

`X` - input tensor

`z` - update gate

`r` - reset gate

`h` - hidden gate

`t` - time step (t-1 means previous time step)

`W[zrh]` - W parameter weight matrix for update, reset, and hidden gates

`R[zrh]` - R recurrence weight matrix for update, reset, and hidden gates

`Wb[zrh]` - W bias vectors for update, reset, and hidden gates

`Rb[zrh]` - R bias vectors for update, reset, and hidden gates

`WB[zrh]` - W parameter weight matrix for backward update, reset, and hidden gates

`RB[zrh]` - R recurrence weight matrix for backward update, reset, and hidden gates

`WBb[zrh]` - W bias vectors for backward update, reset, and hidden gates

`RBb[zrh]` - R bias vectors for backward update, reset, and hidden gates

`H` - Hidden state

`num_directions` - 2 if direction == bidirectional else 1

Activation functions:

  Relu(x)                - max(0, x)

  Tanh(x)                - (1 - e^{-2x})/(1 + e^{-2x})

  Sigmoid(x)             - 1/(1 + e^{-x})

  (NOTE: Below are optional)

  Affine(x)              - alpha*x + beta

  LeakyRelu(x)           - x if x >= 0 else alpha * x

  ThresholdedRelu(x)     - x if x >= alpha else 0

  ScaledTanh(x)          - alpha*Tanh(beta*x)

  HardSigmoid(x)         - min(max(alpha*x + beta, 0), 1)

  Elu(x)                 - x if x >= 0 else alpha*(e^x - 1)

  Softsign(x)            - x/(1 + |x|)

  Softplus(x)            - log(1 + e^x)

Equations (Default: f=Sigmoid, g=Tanh):

  - zt = f(Xt*(Wz^T) + Ht-1*Rz + Wbz + Rbz)

  - rt = f(Xt*(Wr^T) + Ht-1*Rr + Wbr + Rbr)

  - ht = g(Xt*(Wh^T) + (rt (.) Ht-1)*Rh + Rbh + Wbh) # default, when linear_before_reset = 0

  - ht = g(Xt*(Wh^T) + (rt (.) (Ht-1*Rh + Rbh) + Wbh) # when linear_before_reset != 0

  - Ht = (1 - zt) (.) ht + zt (.) Ht-1
This operator has **optional** inputs/outputs. See [the doc](IR.md) for more details about the representation of optional arguments. An empty string may be used in the place of an actual argument's name to indicate a missing argument. Trailing optional arguments (those not followed by an argument that is present) may also be simply omitted.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(GRU, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.activation_alpha = self.attributes.get('activation_alpha')
        self.activation_beta = self.attributes.get('activation_beta')
        self.activations = self.attributes.get('activations')
        self.clip = self.attributes.get('clip')
        self.direction = self.attributes.get('direction')
        self.hidden_size = self.attributes.get('hidden_size')
        self.linear_before_reset = self.attributes.get('linear_before_reset')
        # The input sequences packed (and potentially padded) into one 3-D tensor with the shape of `[seq_length, batch_size, input_size]`.
        self.i_X = self.input[0]
        # The weight tensor for the gates. Concatenation of `W[zrh]` and `WB[zrh]` (if bidirectional) along dimension 0. This tensor has shape `[num_directions, 3*hidden_size, input_size]`.
        self.i_W = self.input[1]
        # The recurrence weight tensor. Concatenation of `R[zrh]` and `RB[zrh]` (if bidirectional) along dimension 0. This tensor has shape `[num_directions, 3*hidden_size, hidden_size]`.
        self.i_R = self.input[2]
        # The bias tensor for the gates. Concatenation of `[Wb[zrh], Rb[zrh]]` and `[WBb[zrh], RBb[zrh]]` (if bidirectional) along dimension 0. This tensor has shape `[num_directions, 6*hidden_size]`. Optional: If not specified - assumed to be 0
        # OPTIONAL
        self.i_B = None if len(self.input) < 4 else self.input[3]
        # Optional tensor specifying lengths of the sequences in a batch. If not specified - assumed all sequences in the batch to have length `seq_length`. It has shape `[batch_size]`.
        # OPTIONAL
        self.i_sequence_lens = None if len(self.input) < 5 else self.input[4]
        # Optional initial value of the hidden. If not specified - assumed to be 0. It has shape `[num_directions, batch_size, hidden_size]`.
        # OPTIONAL
        self.i_initial_h = None if len(self.input) < 6 else self.input[5]
        # A tensor that concats all the intermediate output values of the hidden. It has shape `[seq_length, num_directions, batch_size, hidden_size]`. 
        # OPTIONAL
        self.o_Y = None if len(self.output) < 1 else self.output[0]
        # The last output value of the hidden. It has shape `[num_directions, batch_size, hidden_size]`.
        # OPTIONAL
        self.o_Y_h = None if len(self.output) < 2 else self.output[1]

    def accept(self, visitor, network):
        super(GRU, self).accept(visitor, network)
        visitor.visit_gru(self, network)

    @classmethod
    def create_op(cls, i_X: str, i_W: str, i_R: str, i_B: str, i_sequence_lens: str, i_initial_h: str, o_Y: str, o_Y_h: str, activation_alpha: OnnxAttribute, activation_beta: OnnxAttribute, activations: OnnxAttribute, clip: OnnxAttribute, direction: OnnxAttribute, hidden_size: OnnxAttribute, linear_before_reset: OnnxAttribute):
        attributes = {
            'activation_alpha': activation_alpha,
            'activation_beta': activation_beta,
            'activations': activations,
            'clip': clip,
            'direction': direction,
            'hidden_size': hidden_size,
            'linear_before_reset': linear_before_reset,
        }
        return cls([i_X, i_W, i_R, i_B, i_sequence_lens, i_initial_h], [o_Y, o_Y_h], None, None, None, attributes, None)


class GivenTensorFill(Operation):
    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(GivenTensorFill, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.extra_shape = self.attributes.get('extra_shape')
        self.input_as_shape = self.attributes.get('input_as_shape')
        self.shape = self.attributes.get('shape')
        self.values = self.attributes.get('values')
        # The shape of filled tensor
        # OPTIONAL
        self.i_shape = None if len(self.input) < 1 else self.input[0]
        # The filled tensor
        self.o_X = self.output[0]

    def accept(self, visitor, network):
        super(GivenTensorFill, self).accept(visitor, network)
        visitor.visit_giventensorfill(self, network)

    @classmethod
    def create_op(cls, i_shape: str, o_X: str, extra_shape: OnnxAttribute, input_as_shape: OnnxAttribute, shape: OnnxAttribute, values: OnnxAttribute):
        attributes = {
            'extra_shape': extra_shape,
            'input_as_shape': input_as_shape,
            'shape': shape,
            'values': values,
        }
        return cls([i_shape], [o_X], None, None, None, attributes, None)


class Multinomial(Operation):
    """
Generate a tensor of samples from a multinomial distribution according to the probabilities
of each of the possible outcomes.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Multinomial, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.dtype = self.attributes.get('dtype')
        self.sample_size = self.attributes.get('sample_size')
        self.seed = self.attributes.get('seed')
        # Input tensor with shape [batch_size, class_size], where class_size is the number of all possible outcomes. Each value along the axis zero represents the unnormalized log-probability of each corresponding outcome in a batch.
        self.i_input = self.input[0]
        # Output tensor with shape [batch_size, sample_size], where sample_size is the number of times to sample. Each value along the axis zero represents the outcome of the corresponding sample in a batch.
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Multinomial, self).accept(visitor, network)
        visitor.visit_multinomial(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, dtype: OnnxAttribute, sample_size: OnnxAttribute, seed: OnnxAttribute):
        attributes = {
            'dtype': dtype,
            'sample_size': sample_size,
            'seed': seed,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Flatten(Operation):
    """
Flattens the input tensor into a 2D matrix. If input tensor has shape
(d_0, d_1, ... d_n) then the output will have shape
(d_0 X d_1 ... d_(axis-1), d_axis X d_(axis+1) ... X dn).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Flatten, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        # A tensor of rank >= axis.
        self.i_input = self.input[0]
        # A 2D tensor with the contents of the input tensor, with input dimensions up to axis flattened to the outer dimension of the output and remaining input dimensions flattened into the inner dimension of the output.
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Flatten, self).accept(visitor, network)
        visitor.visit_flatten(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, axis: OnnxAttribute):
        attributes = {
            'axis': axis,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Exp(Operation):
    """
Calculates the exponential of the given input tensor, element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Exp, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_input = self.input[0]
        # The exponential of the input tensor computed element-wise
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Exp, self).accept(visitor, network)
        visitor.visit_exp(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Equal(Operation):
    """
Returns the tensor resulted from performing the `equal` logical operation
elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting support).

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Equal, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # First input operand for the logical operator.
        self.i_A = self.input[0]
        # Second input operand for the logical operator.
        self.i_B = self.input[1]
        # Result tensor.
        self.o_C = self.output[0]

    def accept(self, visitor, network):
        super(Equal, self).accept(visitor, network)
        visitor.visit_equal(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, o_C: str):
        attributes = {
        }
        return cls([i_A, i_B], [o_C], None, None, None, attributes, None)


class Not(Operation):
    """
Returns the negation of the input tensor element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Not, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Not, self).accept(visitor, network)
        visitor.visit_not(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Sqrt(Operation):
    """
Square root takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the square root is, y = x^0.5, is applied to
the tensor elementwise. If x is negative, then it will return NaN.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Sqrt, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Sqrt, self).accept(visitor, network)
        visitor.visit_sqrt(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Elu(Operation):
    """
Elu takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the function `f(x) = alpha * (exp(x) - 1.) for x <
0`, `f(x) = x for x >= 0`., is applied to the tensor elementwise.

    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Elu, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.alpha = self.attributes.get('alpha')
        # 1D input tensor
        self.i_X = self.input[0]
        # 1D input tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Elu, self).accept(visitor, network)
        visitor.visit_elu(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, alpha: OnnxAttribute):
        attributes = {
            'alpha': alpha,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class ReduceMin(Operation):
    """
Computes the min of the input tensor's element along the provided axes. The resulted
tensor has the same rank as the input if keepdims equal 1. If keepdims equal 0, then
the resulted tensor have the reduced dimension pruned.

The above behavior is similar to numpy, with the exception that numpy default keepdims to
False instead of True.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ReduceMin, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ReduceMin, self).accept(visitor, network)
        visitor.visit_reducemin(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axes: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axes': axes,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class Div(Operation):
    """
Performs element-wise binary division (with Numpy-style broadcasting support).

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Div, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # First operand.
        self.i_A = self.input[0]
        # Second operand.
        self.i_B = self.input[1]
        # Result, has same element type as two inputs
        self.o_C = self.output[0]

    def accept(self, visitor, network):
        super(Div, self).accept(visitor, network)
        visitor.visit_div(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, o_C: str):
        attributes = {
        }
        return cls([i_A, i_B], [o_C], None, None, None, attributes, None)


class PRelu(Operation):
    """
PRelu takes input data (Tensor<T>) and slope tensor as input, and produces one
output data (Tensor<T>) where the function `f(x) = slope * x for x < 0`,
`f(x) = x for x >= 0`., is applied to the data tensor elementwise.
This operator supports **unidirectional broadcasting** (tensor slope should be unidirectional broadcastable to input tensor X); for more details please check [the doc](Broadcasting.md).    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(PRelu, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_X = self.input[0]
        # Slope tensor. The shape of slope can be smaller then first input X; if so, its shape must be unidirectional broadcastable to X
        self.i_slope = self.input[1]
        # Output tensor (same size as X)
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(PRelu, self).accept(visitor, network)
        visitor.visit_prelu(self, network)

    @classmethod
    def create_op(cls, i_X: str, i_slope: str, o_Y: str):
        attributes = {
        }
        return cls([i_X, i_slope], [o_Y], None, None, None, attributes, None)


class DepthToSpace(Operation):
    """DepthToSpace rearranges (permutes) data from depth into blocks of spatial data.
This is the reverse transformation of SpaceToDepth. More specifically, this op outputs a copy of
the input tensor where values from the depth dimension are moved in spatial blocks to the height
and width dimensions.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(DepthToSpace, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.blocksize = self.attributes.get('blocksize')
        # Input tensor of [N,C,H,W], where N is the batch axis, C is the channel or depth, H is the height and W is the width.
        self.i_input = self.input[0]
        # Output tensor of [N, C/(blocksize * blocksize), H * blocksize, W * blocksize].
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(DepthToSpace, self).accept(visitor, network)
        visitor.visit_depthtospace(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, blocksize: OnnxAttribute):
        attributes = {
            'blocksize': blocksize,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class GRUUnit(Operation):
    """
GRUUnit computes the activations of a standard GRU,
in a sequence-length aware fashion.
Concretely, given the (fused) inputs X (TxNxD), the previous hidden
state (NxD), and the sequence lengths (N), computes the GRU
activations, avoiding computation if the input is invalid (as in, the
value at X[t][n] >= seqLengths[n].
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(GRUUnit, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.drop_states = self.attributes.get('drop_states')
        # The previous GRU hidden state.
        self.i_hidden_prev = self.input[0]
        # Unactivated gate outputs from forget, update, and output gates, pre-activation.
        self.i_gates = self.input[1]
        # Array of sequence lengths.  len(seq_lengths) should equal batch size N.
        self.i_seq_lengths = self.input[2]
        # The timestep for this operation.
        self.i_t = self.input[3]
        # The new GRU hidden state calculated by this op.
        self.o_hidden = self.output[0]

    def accept(self, visitor, network):
        super(GRUUnit, self).accept(visitor, network)
        visitor.visit_gruunit(self, network)

    @classmethod
    def create_op(cls, i_hidden_prev: str, i_gates: str, i_seq_lengths: str, i_t: str, o_hidden: str, drop_states: OnnxAttribute):
        attributes = {
            'drop_states': drop_states,
        }
        return cls([i_hidden_prev, i_gates, i_seq_lengths, i_t], [o_hidden], None, None, None, attributes, None)


class ConvTranspose(Operation):
    """
The convolution transpose operator consumes an input tensor and a filter,
and computes the output. 

If the pads parameter is provided the shape of the output is calculated via the following equation:

  output_shape[i] = stride[i] * (input_size[i] - 1) + output_padding[i] + kernel_shape[i] - pads[start_i] - pads[end_i]

output_shape can also be explicitly specified in which case pads values are auto generated using these equations:

  total_padding[i] = stride[i] * (input_size[i] - 1) + output_padding[i] + kernel_shape[i] - output_shape[i]
  If (auto_pads != SAME_UPPER): pads[start_i] = total_padding[i]/2; pads[end_i] = total_padding[i] - (total_padding[i]/2)
  Else: pads[start_i] = total_padding[i] - (total_padding[i]/2); pads[end_i] = (total_padding[i]/2).

        """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ConvTranspose, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.auto_pad = self.attributes.get('auto_pad')
        self.dilations = self.attributes.get('dilations')
        self.group = self.attributes.get('group')
        self.kernel_shape = self.attributes.get('kernel_shape')
        self.output_padding = self.attributes.get('output_padding')
        self.output_shape = self.attributes.get('output_shape')
        self.pads = self.attributes.get('pads')
        self.strides = self.attributes.get('strides')
        # Input data tensor from previous layer; has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and width. Note that this is for the 2D image.Otherwise the size is (N x D1 x D2 ... x Dn)
        self.i_X = self.input[0]
        # The weight tensor that will be used in the convolutions; has size (C x M x kH x kW), where C is the number of channels, and kH and kW are the height and width of the kernel, and M is the number of feature maps. For more than 2 dimensions, the weight shape will be (C x M x k1 x k2 x ... x kn), where (k1 x k2 x ... x kn) is the dimension of the kernel
        self.i_W = self.input[1]
        # Optional 1D bias to be added to the convolution, has size of C.
        # OPTIONAL
        self.i_B = None if len(self.input) < 3 else self.input[2]
        # Output data tensor that contains the result of the convolution. The output dimensions are functions of the kernel size, stride size, and pad lengths.
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(ConvTranspose, self).accept(visitor, network)
        visitor.visit_convtranspose(self, network)

    @classmethod
    def create_op(cls, i_X: str, i_W: str, i_B: str, o_Y: str, auto_pad: OnnxAttribute, dilations: OnnxAttribute, group: OnnxAttribute, kernel_shape: OnnxAttribute, output_padding: OnnxAttribute, output_shape: OnnxAttribute, pads: OnnxAttribute, strides: OnnxAttribute):
        attributes = {
            'auto_pad': auto_pad,
            'dilations': dilations,
            'group': group,
            'kernel_shape': kernel_shape,
            'output_padding': output_padding,
            'output_shape': output_shape,
            'pads': pads,
            'strides': strides,
        }
        return cls([i_X, i_W, i_B], [o_Y], None, None, None, attributes, None)


class LogSoftmax(Operation):
    """
The operator computes the logsoftmax (log of softmax) values for each layer in the batch
 of the given input. The input is a 2-D tensor (Tensor<float>) of size
(batch_size x input_feature_dimensions). The output tensor has the same shape
and contains the logsoftmax values of the corresponding input.

X does not need to explicitly be a 2D vector; rather, it will be
coerced into one. For an arbitrary n-dimensional tensor
X \in [a_0, a_1, ..., a_{k-1}, a_k, ..., a_{n-1}] and k is
the axis provided, then X will be coerced into a 2-dimensional tensor with
dimensions [a_0 * ... * a_{k-1}, a_k * ... * a_{n-1}]. For the default
case where axis=1, this means the X tensor will be coerced into a 2D tensor
of dimensions [a_0, a_1 * ... * a_{n-1}], where a_0 is often the batch size.
In this situation, we must have a_0 = N and a_1 * ... * a_{n-1} = D.
Each of these dimensions must be matched correctly, or else the operator
will throw errors.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(LogSoftmax, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        # The input tensor that's coerced into a 2D matrix of size (NxD) as described above.
        self.i_input = self.input[0]
        # The output values with the same shape as input tensor.
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(LogSoftmax, self).accept(visitor, network)
        visitor.visit_logsoftmax(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, axis: OnnxAttribute):
        attributes = {
            'axis': axis,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class ReduceLogSum(Operation):
    """
Computes the log sum of the input tensor's element along the provided axes. The resulted
tensor has the same rank as the input if keepdims equal 1. If keepdims equal 0, then
the resulted tensor have the reduced dimension pruned.

The above behavior is similar to numpy, with the exception that numpy default keepdims to
False instead of True.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ReduceLogSum, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ReduceLogSum, self).accept(visitor, network)
        visitor.visit_reducelogsum(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axes: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axes': axes,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class ReduceMean(Operation):
    """
Computes the mean of the input tensor's element along the provided axes. The resulted
tensor has the same rank as the input if keepdims equal 1. If keepdims equal 0, then
the resulted tensor have the reduced dimension pruned.

The above behavior is similar to numpy, with the exception that numpy default keepdims to
False instead of True.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ReduceMean, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ReduceMean, self).accept(visitor, network)
        visitor.visit_reducemean(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axes: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axes': axes,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class Crop(Operation):
    """Crop and image to the specified spatial dimensions. If scale is given,
then optionally start the crop offset by the left/top border amounts.
If scale is not provided, crop the borders as provided.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Crop, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.border = self.attributes.get('border')
        self.scale = self.attributes.get('scale')
        # Input tensor of shape [N,C,H,W]
        self.i_input = self.input[0]
        # Result, has same type as input, with H and W dimensions reduced.
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Crop, self).accept(visitor, network)
        visitor.visit_crop(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, border: OnnxAttribute, scale: OnnxAttribute):
        attributes = {
            'border': border,
            'scale': scale,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class And(Operation):
    """
Returns the tensor resulted from performing the `and` logical operation
elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting support).

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(And, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # First input operand for the logical operator.
        self.i_A = self.input[0]
        # Second input operand for the logical operator.
        self.i_B = self.input[1]
        # Result tensor.
        self.o_C = self.output[0]

    def accept(self, visitor, network):
        super(And, self).accept(visitor, network)
        visitor.visit_and(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, o_C: str):
        attributes = {
        }
        return cls([i_A, i_B], [o_C], None, None, None, attributes, None)


class ReduceMax(Operation):
    """
Computes the max of the input tensor's element along the provided axes. The resulted
tensor has the same rank as the input if keepdims equal 1. If keepdims equal 0, then
the resulted tensor have the reduced dimension pruned.

The above behavior is similar to numpy, with the exception that numpy default keepdims to
False instead of True.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ReduceMax, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ReduceMax, self).accept(visitor, network)
        visitor.visit_reducemax(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axes: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axes': axes,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class ArgMax(Operation):
    """
Computes the indices of the max elements of the input tensor's element along the 
provided axis. The resulted tensor has the same rank as the input if keepdims equal 1.
If keepdims equal 0, then the resulted tensor have the reduced dimension pruned. 
The type of the output tensor is integer.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ArgMax, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor with integer data type.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ArgMax, self).accept(visitor, network)
        visitor.visit_argmax(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axis: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axis': axis,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class LpNormalization(Operation):
    """
Given a matrix, apply Lp-normalization along the provided axis.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(LpNormalization, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        self.p = self.attributes.get('p')
        # Input matrix
        self.i_input = self.input[0]
        # Matrix after normalization
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(LpNormalization, self).accept(visitor, network)
        visitor.visit_lpnormalization(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, axis: OnnxAttribute, p: OnnxAttribute):
        attributes = {
            'axis': axis,
            'p': p,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Loop(Operation):
    """
Generic Looping construct. This loop has multiple termination conditions:

1) Trip count. Iteration count specified at runtime. Set by
   specifying the input M. Optional. Set to empty string to omit.
   Note that a static trip count (specified at graph construction time) can be
   specified by passing in a constant node for input M.
2) Loop termination condition. This is an input to the op that determines
   whether to run the first iteration and also a loop-carried dependency for
   the body graph. The body graph must yield a value for the condition variable,
   whether this input is provided or not.

This table summarizes the operating modes of this operator with equivalent
C-style code:

    Operator inputs defined as (max_trip_count, condition_var).

    input ("", ""):
        for (int i=0; ; ++i) {
          cond = ... // Note this value is ignored, but is required in the body
        }

    input ("", cond) // Note this is analogous to a while loop
        bool cond = ...;
        for (int i=0; cond; ++i) {
          cond = ...;
        }

    input ("", 1) // Note this is analogous to a do-while loop
        bool cond = true
        for (int i=0; cond; ++i) {
          cond = ...;
        }

    input (trip_count, "") // Note this is analogous to a for loop
        int trip_count = ...
        for (int i=0; i < trip_count; ++i) {
          cond = ...; // ignored
        }

    input (trip_count, cond)
        int trip_count = ...;
        bool cond = ...;
        for (int i=0; i < trip_count && cond; ++i) {
          cond = ...;
        }


*Sample usage - cond as well as trip count*

    graph predict-net {
      %a = Constant[value = <Scalar Tensor [3]>]()
      %b = Constant[value = <Scalar Tensor [6]>]()
      %keepgoing = Constant[value = <Scalar Tensor [1]>]()
      %max_trip_count = Constant[value = <Scalar Tensor [10]>]()
      %keepgoing_out, %b_out, %user_defined_vals = Loop[body = <graph body-net>](%max_trip_count, %keepgoing, %b)
      return
    }

    graph body-net (
      %i[INT32, scalar]
      %keepgoing[BOOL, scalar]
      %b[INT32, scalar]
    ) {
      %my_local = Add(%a, %b)
      %b_out = Sub(%a, %b)
      %keepgoing_out = Greater(%my_local, %b_out)
      %user_defined_vals = Add(%b, %b)
      return %keepgoing_out, %b_out, %user_defined_vals
    }

*Sample equivalent C code*

    {
      /* User-defined code (enclosing scope) */
      int a = 3, b = 6;
      bool keepgoing = true; // Analogous to input cond
      /* End user-defined code */

      /* Implicitly-defined code */
      const int max_trip_count = 10; // Analogous to input M
      int user_defined_vals[]; // Imagine this is resizable
      /* End implicitly-defined code */
      for (int i=0; i < max_trip_count && keepgoing; ++i) {
        /* User-defined code (loop body) */
        int my_local = a + b; // Reading values in the enclosing scope is fine
        b = a - b; // writes fine if we specify b as a loop-carried dependency
        keepgoing = my_local > b; // keepgoing is a loop-carried dependency
        user_defined_vals[i] = b + b;
        /* End user-defined code */
      }
      // my_local = 123; // Can't do this. my_local was defined in the the body

      // These below values are live-out from the loop and therefore accessible
      b_out; user_defined_vals; keepgoing_out;
    }

There are several things of note in this code snippet:

1) Values from the enclosing scope (i.e. variable a here) are in scope and can
   be referenced in the inputs of the loop.
2) Any variables which you wish to make available in the enclosing scope (i.e.
   the variables b and keepgoing) must be declared as either loop-carried
   dependencies (both at the op inputs and output and at the body net input and
   output) or scan_outputs.
3) Values created in the body cannot be accessed in the enclosing scope.

Note that the semantics of this op support "diagonal" or "wavefront" execution.
(See Step 3 here for an example:
https://devblogs.nvidia.com/optimizing-recurrent-neural-networks-cudnn-5/).
Frontends should emit multi-layer RNNs as a series of While operators (with
time being the inner looping dimension), with each successive layer consuming
the scan_outputs from the previous layer, possibly going through several
point-wise operators (e.g. dropout, residual connections, linear layer).
Concretely, the (possibly transformed) scan_outputs are referenced by the
subsequent layer as a LoopIndexTensor operating on a value in scope, not
necessarily a loop-carried dependency. Backends can recognize this pattern and
are permitted to schedule the execution of the multi-layer network in a
pipelined/"wavefront" fashion.

    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Loop, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.body = self.attributes.get('body')
        # A maximum trip-count for the loop specified at runtime. Optional. pass empty string to skip.
        self.i_M = self.input[0]
        # A boolean termination condition. Pass empty string to skip.
        self.i_cond = self.input[1]
        # The initial values of any loop-carried dependencies (values that change across loop iterations)
        # input is variadic [1,infty) just use self.input to access whole list
        # Final N loop carried dependency values then K scan_outputs
        # output is variadic [1,infty) just use self.output to access whole list

    def accept(self, visitor, network):
        super(Loop, self).accept(visitor, network)
        visitor.visit_loop(self, network)

    @classmethod
    def create_op(cls, i_M: str, i_cond: str, i_v_initial: str, o_v_final_and_scan_outputs: str, body: OnnxAttribute):
        attributes = {
            'body': body,
        }
        return cls([i_M, i_cond, i_v_initial], [o_v_final_and_scan_outputs], None, None, None, attributes, None)


class Affine(Operation):
    """
Affine takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the affine function, y = alpha * x + beta,
is applied to the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Affine, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.alpha = self.attributes.get('alpha')
        self.beta = self.attributes.get('beta')
        # 1D input tensor
        self.i_X = self.input[0]
        # 1D output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Affine, self).accept(visitor, network)
        visitor.visit_affine(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, alpha: OnnxAttribute, beta: OnnxAttribute):
        attributes = {
            'alpha': alpha,
            'beta': beta,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class LSTM(Operation):
    """
Computes an one-layer LSTM. This operator is usually supported via some
custom implementation such as CuDNN.

Notations:

`X` - input tensor

`i` - input gate

`o` - output gate

`f` - forget gate

`c` - cell gate

`t` - time step (t-1 means previous time step)

`W[iofc]` - W parameter weight matrix for input, output, forget, and cell gates

`R[iofc]` - R recurrence weight matrix for input, output, forget, and cell gates

`Wb[iofc]` - W bias vectors for input, output, forget, and cell gates

`Rb[iofc]` - R bias vectors for input, output, forget, and cell gates

`P[iof]`  - P peephole weight vector for input, output, and forget gates

`WB[iofc]` - W parameter weight matrix for backward input, output, forget, and cell gates

`RB[iofc]` - R recurrence weight matrix for backward input, output, forget, and cell gates

`WBb[iofc]` - W bias vectors for backward input, output, forget, and cell gates

`RBb[iofc]` - R bias vectors for backward input, output, forget, and cell gates

`PB[iof]`  - P peephole weight vector for backward input, output, and forget gates

`H` - Hidden state

`num_directions` - 2 if direction == bidirectional else 1

Activation functions:

  Relu(x)                - max(0, x)

  Tanh(x)                - (1 - e^{-2x})/(1 + e^{-2x})

  Sigmoid(x)             - 1/(1 + e^{-x})

  (NOTE: Below are optional)

  Affine(x)              - alpha*x + beta

  LeakyRelu(x)           - x if x >= 0 else alpha * x

  ThresholdedRelu(x)     - x if x >= alpha else 0

  ScaledTanh(x)          - alpha*Tanh(beta*x)

  HardSigmoid(x)         - min(max(alpha*x + beta, 0), 1)

  Elu(x)                 - x if x >= 0 else alpha*(e^x - 1)

  Softsign(x)            - x/(1 + |x|)

  Softplus(x)            - log(1 + e^x)

Equations (Default: f=Sigmoid, g=Tanh, h=Tanh):

  - it = f(Xt*(Wi^T) + Ht-1*Ri + Pi (.) Ct-1 + Wbi + Rbi)

  - ft = f(Xt*(Wf^T) + Ht-1*Rf + Pf (.) Ct-1 + Wbf + Rbf)

  - ct = g(Xt*(Wc^T) + Ht-1*Rc + Wbc + Rbc)

  - Ct = ft (.) Ct-1 + it (.) ct

  - ot = f(Xt*(Wo^T) + Ht-1*Ro + Po (.) Ct + Wbo + Rbo)

  - Ht = ot (.) h(Ct)
This operator has **optional** inputs/outputs. See [the doc](IR.md) for more details about the representation of optional arguments. An empty string may be used in the place of an actual argument's name to indicate a missing argument. Trailing optional arguments (those not followed by an argument that is present) may also be simply omitted.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(LSTM, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.activation_alpha = self.attributes.get('activation_alpha')
        self.activation_beta = self.attributes.get('activation_beta')
        self.activations = self.attributes.get('activations')
        self.clip = self.attributes.get('clip')
        self.direction = self.attributes.get('direction')
        self.hidden_size = self.attributes.get('hidden_size')
        self.input_forget = self.attributes.get('input_forget')
        # The input sequences packed (and potentially padded) into one 3-D tensor with the shape of `[seq_length, batch_size, input_size]`.
        self.i_X = self.input[0]
        # The weight tensor for the gates. Concatenation of `W[iofc]` and `WB[iofc]` (if bidirectional) along dimension 0. The tensor has shape `[num_directions, 4*hidden_size, input_size]`.
        self.i_W = self.input[1]
        # The recurrence weight tensor. Concatenation of `R[iofc]` and `RB[iofc]` (if bidirectional) along dimension 0. This tensor has shape `[num_directions, 4*hidden_size, hidden_size]`.
        self.i_R = self.input[2]
        # The bias tensor for input gate. Concatenation of `[Wb[iofc], Rb[iofc]]`, and `[WBb[iofc], RBb[iofc]]` (if bidirectional) along dimension 0. This tensor has shape `[num_directions, 8*hidden_size]`. Optional: If not specified - assumed to be 0.
        # OPTIONAL
        self.i_B = None if len(self.input) < 4 else self.input[3]
        # Optional tensor specifying lengths of the sequences in a batch. If not specified - assumed all sequences in the batch to have length `seq_length`. It has shape `[batch_size]`.
        # OPTIONAL
        self.i_sequence_lens = None if len(self.input) < 5 else self.input[4]
        # Optional initial value of the hidden. If not specified - assumed to be 0. It has shape `[num_directions, batch_size, hidden_size]`.
        # OPTIONAL
        self.i_initial_h = None if len(self.input) < 6 else self.input[5]
        # Optional initial value of the cell. If not specified - assumed to be 0. It has shape `[num_directions, batch_size, hidden_size]`.
        # OPTIONAL
        self.i_initial_c = None if len(self.input) < 7 else self.input[6]
        # The weight tensor for peepholes. Concatenation of `P[iof]` and `PB[iof]` (if bidirectional) along dimension 0. It has shape `[num_directions, 3*hidde_size]`. Optional: If not specified - assumed to be 0.
        # OPTIONAL
        self.i_P = None if len(self.input) < 8 else self.input[7]
        # A tensor that concats all the intermediate output values of the hidden. It has shape `[seq_length, num_directions, batch_size, hidden_size]`. 
        # OPTIONAL
        self.o_Y = None if len(self.output) < 1 else self.output[0]
        # The last output value of the hidden. It has shape `[num_directions, batch_size, hidden_size]`.
        # OPTIONAL
        self.o_Y_h = None if len(self.output) < 2 else self.output[1]
        # The last output value of the cell. It has shape `[num_directions, batch_size, hidden_size]`.
        # OPTIONAL
        self.o_Y_c = None if len(self.output) < 3 else self.output[2]

    def accept(self, visitor, network):
        super(LSTM, self).accept(visitor, network)
        visitor.visit_lstm(self, network)

    @classmethod
    def create_op(cls, i_X: str, i_W: str, i_R: str, i_B: str, i_sequence_lens: str, i_initial_h: str, i_initial_c: str, i_P: str, o_Y: str, o_Y_h: str, o_Y_c: str, activation_alpha: OnnxAttribute, activation_beta: OnnxAttribute, activations: OnnxAttribute, clip: OnnxAttribute, direction: OnnxAttribute, hidden_size: OnnxAttribute, input_forget: OnnxAttribute):
        attributes = {
            'activation_alpha': activation_alpha,
            'activation_beta': activation_beta,
            'activations': activations,
            'clip': clip,
            'direction': direction,
            'hidden_size': hidden_size,
            'input_forget': input_forget,
        }
        return cls([i_X, i_W, i_R, i_B, i_sequence_lens, i_initial_h, i_initial_c, i_P], [o_Y, o_Y_h, o_Y_c], None, None, None, attributes, None)


class Softplus(Operation):
    """
Softplus takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the softplus function, y = ln(exp(x) + 1), is applied to
the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Softplus, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # 1D input tensor
        self.i_X = self.input[0]
        # 1D input tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Softplus, self).accept(visitor, network)
        visitor.visit_softplus(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class RandomNormalLike(Operation):
    """
Generate a tensor with random values drawn from a normal distribution. 
The shape of the output tensor is copied from the shape of the input tensor, 
and the parameters of the normal distribution are specified by `mean` and `scale`.

The data type is specified by the 'dtype' argument, or copied from the input tensor if not provided. 
The 'dtype' argument must be one of the data types specified in the 'DataType' enum field in the
TensorProto message, and be valid as an output type.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(RandomNormalLike, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.dtype = self.attributes.get('dtype')
        self.mean = self.attributes.get('mean')
        self.scale = self.attributes.get('scale')
        self.seed = self.attributes.get('seed')
        # Input tensor to copy shape and optionally type information from.
        self.i_input = self.input[0]
        # Output tensor of random values drawn from normal distribution
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(RandomNormalLike, self).accept(visitor, network)
        visitor.visit_randomnormallike(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, dtype: OnnxAttribute, mean: OnnxAttribute, scale: OnnxAttribute, seed: OnnxAttribute):
        attributes = {
            'dtype': dtype,
            'mean': mean,
            'scale': scale,
            'seed': seed,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class ArgMin(Operation):
    """
Computes the indices of the min elements of the input tensor's element along the 
provided axis. The resulted tensor has the same rank as the input if keepdims equal 1.
If keepdims equal 0, then the resulted tensor have the reduced dimension pruned. 
The type of the output tensor is integer.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ArgMin, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor with integer data type.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ArgMin, self).accept(visitor, network)
        visitor.visit_argmin(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axis: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axis': axis,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class Conv(Operation):
    """
The convolution operator consumes an input tensor and a filter, and
computes the output.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Conv, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.auto_pad = self.attributes.get('auto_pad')
        self.dilations = self.attributes.get('dilations')
        self.group = self.attributes.get('group')
        self.kernel_shape = self.attributes.get('kernel_shape')
        self.pads = self.attributes.get('pads')
        self.strides = self.attributes.get('strides')
        # Input data tensor from previous layer; has size (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and width. Note that this is for the 2D image. Otherwise the size is (N x C x D1 x D2 ... x Dn). Optionally, if dimension denotation is in effect, the operation expects input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...].
        self.i_X = self.input[0]
        # The weight tensor that will be used in the convolutions; has size (M x C x kH x kW), where C is the number of channels, and kH and kW are the height and width of the kernel, and M is the number of feature maps. For more than 2 dimensions, the kernel shape will be (M x C x k1 x k2 x ... x kn), where (k1 x k2 x ... kn) is the dimension of the kernel. Optionally, if dimension denotation is in effect, the operation expects the weight tensor to arrive with the dimension denotation of [FILTER_IN_CHANNEL, FILTER_OUT_CHANNEL, FILTER_SPATIAL, FILTER_SPATIAL ...].
        self.i_W = self.input[1]
        # Optional 1D bias to be added to the convolution, has size of M.
        # OPTIONAL
        self.i_B = None if len(self.input) < 3 else self.input[2]
        # Output data tensor that contains the result of the convolution. The output dimensions are functions of the kernel size, stride size, and pad lengths.
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Conv, self).accept(visitor, network)
        visitor.visit_conv(self, network)

    @classmethod
    def create_op(cls, i_X: str, i_W: str, i_B: str, o_Y: str, auto_pad: OnnxAttribute, dilations: OnnxAttribute, group: OnnxAttribute, kernel_shape: OnnxAttribute, pads: OnnxAttribute, strides: OnnxAttribute):
        attributes = {
            'auto_pad': auto_pad,
            'dilations': dilations,
            'group': group,
            'kernel_shape': kernel_shape,
            'pads': pads,
            'strides': strides,
        }
        return cls([i_X, i_W, i_B], [o_Y], None, None, None, attributes, None)


class Add(Operation):
    """
Performs element-wise binary addition (with Numpy-style broadcasting support).

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Add, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # First operand.
        self.i_A = self.input[0]
        # Second operand.
        self.i_B = self.input[1]
        # Result, has same element type as two inputs
        self.o_C = self.output[0]

    def accept(self, visitor, network):
        super(Add, self).accept(visitor, network)
        visitor.visit_add(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, o_C: str):
        attributes = {
        }
        return cls([i_A, i_B], [o_C], None, None, None, attributes, None)


class Abs(Operation):
    """
Absolute takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the absolute is, y = abs(x), is applied to
the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Abs, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Abs, self).accept(visitor, network)
        visitor.visit_abs(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Split(Operation):
    """Split a tensor into a list of tensors, along the specified
'axis'. Lengths of the parts can be specified using argument 'split'.
Otherwise, the tensor is split to equal sized parts.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Split, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        self.split = self.attributes.get('split')
        # The tensor to split
        self.i_input = self.input[0]
        # One or more outputs forming list of tensors after splitting
        # output is variadic [1,infty) just use self.output to access whole list

    def accept(self, visitor, network):
        super(Split, self).accept(visitor, network)
        visitor.visit_split(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_outputs: str, axis: OnnxAttribute, split: OnnxAttribute):
        attributes = {
            'axis': axis,
            'split': split,
        }
        return cls([i_input], [o_outputs], None, None, None, attributes, None)


class BatchNormalization(Operation):
    """
Carries out batch normalization as described in the paper
https://arxiv.org/abs/1502.03167. Depending on the mode it is being run,
there are multiple cases for the number of outputs, which we list below:

Output case #1: Y, mean, var, saved_mean, saved_var (training mode)
Output case #2: Y (test mode)
    This operator has **optional** inputs/outputs. See [the doc](IR.md) for more details about the representation of optional arguments. An empty string may be used in the place of an actual argument's name to indicate a missing argument. Trailing optional arguments (those not followed by an argument that is present) may also be simply omitted.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(BatchNormalization, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.epsilon = self.attributes.get('epsilon')
        self.momentum = self.attributes.get('momentum')
        self.spatial = self.attributes.get('spatial')
        # Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size.
        self.i_X = self.input[0]
        # The scale as a 1-dimensional tensor of size C to be applied to the output.
        self.i_scale = self.input[1]
        # The bias as a 1-dimensional tensor of size C to be applied to the output.
        self.i_B = self.input[2]
        # The running mean (training) or the estimated mean (testing) as a 1-dimensional tensor of size C.
        self.i_mean = self.input[3]
        # The running variance (training) or the estimated variance (testing) as a 1-dimensional tensor of size C.
        self.i_var = self.input[4]
        # The output tensor of the same shape as X.
        self.o_Y = self.output[0]
        # The running mean after the BatchNormalization operator.
        # OPTIONAL
        self.o_mean = None if len(self.output) < 2 else self.output[1]
        # The running variance after the BatchNormalization operator.
        # OPTIONAL
        self.o_var = None if len(self.output) < 3 else self.output[2]
        # Saved mean used during training to speed up gradient computation.
        # OPTIONAL
        self.o_saved_mean = None if len(self.output) < 4 else self.output[3]
        # Saved variance used during training to speed up gradient computation.
        # OPTIONAL
        self.o_saved_var = None if len(self.output) < 5 else self.output[4]

    def accept(self, visitor, network):
        super(BatchNormalization, self).accept(visitor, network)
        visitor.visit_batchnormalization(self, network)

    @classmethod
    def create_op(cls, i_X: str, i_scale: str, i_B: str, i_mean: str, i_var: str, o_Y: str, o_mean: str, o_var: str, o_saved_mean: str, o_saved_var: str, epsilon: OnnxAttribute, momentum: OnnxAttribute, spatial: OnnxAttribute):
        attributes = {
            'epsilon': epsilon,
            'momentum': momentum,
            'spatial': spatial,
        }
        return cls([i_X, i_scale, i_B, i_mean, i_var], [o_Y, o_mean, o_var, o_saved_mean, o_saved_var], None, None, None, attributes, None)


class Upsample(Operation):
    """
Upsample the input tensor.
Each dimension value of the output tensor is:
  output_dimension = floor(input_dimension * scale).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Upsample, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.mode = self.attributes.get('mode')
        self.scales = self.attributes.get('scales')
        # N-D tensor
        self.i_X = self.input[0]
        # N-D tensor after resizing
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Upsample, self).accept(visitor, network)
        visitor.visit_upsample(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, mode: OnnxAttribute, scales: OnnxAttribute):
        attributes = {
            'mode': mode,
            'scales': scales,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class GlobalLpPool(Operation):
    """
 GlobalLpPool consumes an input tensor X and applies lp pool pooling across the
 the values in the same channel. This is equivalent to LpPool with kernel size
 equal to the spatial dimension of input tensor.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(GlobalLpPool, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.p = self.attributes.get('p')
        # Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size.
        self.i_X = self.input[0]
        # Output data tensor from pooling across the input tensor. Dimensions will be N x C x 1 x 1
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(GlobalLpPool, self).accept(visitor, network)
        visitor.visit_globallppool(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, p: OnnxAttribute):
        attributes = {
            'p': p,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class ReduceLogSumExp(Operation):
    """
Computes the log sum exponent of the input tensor's element along the provided axes. The resulted
tensor has the same rank as the input if keepdims equal 1. If keepdims equal 0, then
the resulted tensor have the reduced dimension pruned.

The above behavior is similar to numpy, with the exception that numpy default keepdims to
False instead of True.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ReduceLogSumExp, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ReduceLogSumExp, self).accept(visitor, network)
        visitor.visit_reducelogsumexp(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axes: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axes': axes,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class MatMul(Operation):
    """
Matrix product that behaves like numpy.matmul: https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.matmul.html
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(MatMul, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # N-dimensional matrix A
        self.i_A = self.input[0]
        # N-dimensional matrix B
        self.i_B = self.input[1]
        # Matrix multiply results from A * B
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(MatMul, self).accept(visitor, network)
        visitor.visit_matmul(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, o_Y: str):
        attributes = {
        }
        return cls([i_A, i_B], [o_Y], None, None, None, attributes, None)


class Sub(Operation):
    """
Performs element-wise binary subtraction (with Numpy-style broadcasting support).

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Sub, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # First operand.
        self.i_A = self.input[0]
        # Second operand.
        self.i_B = self.input[1]
        # Result, has same element type as two inputs
        self.o_C = self.output[0]

    def accept(self, visitor, network):
        super(Sub, self).accept(visitor, network)
        visitor.visit_sub(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, o_C: str):
        attributes = {
        }
        return cls([i_A, i_B], [o_C], None, None, None, attributes, None)


class MaxPool(Operation):
    """
 MaxPool consumes an input tensor X and applies max pooling across the
 the tensor according to kernel sizes, stride sizes, and pad lengths.
 max pooling consisting of computing the max on all values of a
 subset of the input tensor according to the kernel size and downsampling the
 data into the output tensor Y for further processing. The output spatial shape will be following:
 ```
 output_spatial_shape[i] = floor((input_spatial_shape[i] + pad_shape[i] - kernel_spatial_shape[i]) / strides_spatial_shape[i] + 1)

 * pad_shape[i] is sum of pads along axis i
 ```

 `auto_pad` is a DEPRECATED attribute. If you are using them currently, the output spatial shape will be following:
 ```
 VALID: output_spatial_shape[i] = ceil((input_spatial_shape[i] - kernel_spatial_shape[i] + 1) / strides_spatial_shape[i])
 SAME_UPPER or SAME_LOWER: output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides_spatial_shape[i])
 ```
 And pad shape will be following if `SAME_UPPER` or `SAME_LOWER`:
 ```
 pad_shape[i] = (output_spatial_shape[i] - 1) * strides_spatial_shape[i] + kernel_spatial_shape[i] - input_spatial_shape[i]
 ```
 The output of each pooling window is maximum number of elements exclude pad.
     """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(MaxPool, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.auto_pad = self.attributes.get('auto_pad')
        self.kernel_shape = self.attributes.get('kernel_shape')
        self.pads = self.attributes.get('pads')
        self.strides = self.attributes.get('strides')
        # Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size. Optionally, if dimension denotation is in effect, the operation expects the input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...].
        self.i_X = self.input[0]
        # Output data tensor from average or max pooling across the input tensor. Dimensions will vary based on various kernel, stride, and pad sizes. Floor value of the dimension is used
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(MaxPool, self).accept(visitor, network)
        visitor.visit_maxpool(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, auto_pad: OnnxAttribute, kernel_shape: OnnxAttribute, pads: OnnxAttribute, strides: OnnxAttribute):
        attributes = {
            'auto_pad': auto_pad,
            'kernel_shape': kernel_shape,
            'pads': pads,
            'strides': strides,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Neg(Operation):
    """
Neg takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where each element flipped sign, y = -x, is applied to
the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Neg, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Neg, self).accept(visitor, network)
        visitor.visit_neg(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Xor(Operation):
    """
Returns the tensor resulted from performing the `xor` logical operation
elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting support).

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Xor, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # First input operand for the logical operator.
        self.i_A = self.input[0]
        # Second input operand for the logical operator.
        self.i_B = self.input[1]
        # Result tensor.
        self.o_C = self.output[0]

    def accept(self, visitor, network):
        super(Xor, self).accept(visitor, network)
        visitor.visit_xor(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, o_C: str):
        attributes = {
        }
        return cls([i_A, i_B], [o_C], None, None, None, attributes, None)


class Greater(Operation):
    """
Returns the tensor resulted from performing the `greater` logical operation
elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting support).

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Greater, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # First input operand for the logical operator.
        self.i_A = self.input[0]
        # Second input operand for the logical operator.
        self.i_B = self.input[1]
        # Result tensor.
        self.o_C = self.output[0]

    def accept(self, visitor, network):
        super(Greater, self).accept(visitor, network)
        visitor.visit_greater(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, o_C: str):
        attributes = {
        }
        return cls([i_A, i_B], [o_C], None, None, None, attributes, None)


class Dropout(Operation):
    """
Dropout takes one input data (Tensor<float>) and produces two Tensor outputs,
output (Tensor<float>) and mask (Tensor<bool>). Depending on whether it is in
test mode or not, the output Y will either be a random dropout, or a simple
copy of the input. Note that our implementation of Dropout does scaling in
the training phase, so during testing nothing needs to be done.
This operator has **optional** inputs/outputs. See [the doc](IR.md) for more details about the representation of optional arguments. An empty string may be used in the place of an actual argument's name to indicate a missing argument. Trailing optional arguments (those not followed by an argument that is present) may also be simply omitted.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Dropout, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.ratio = self.attributes.get('ratio')
        # The input data as Tensor.
        self.i_data = self.input[0]
        # The output.
        self.o_output = self.output[0]
        # The output mask.
        # OPTIONAL
        self.o_mask = None if len(self.output) < 2 else self.output[1]

    def accept(self, visitor, network):
        super(Dropout, self).accept(visitor, network)
        visitor.visit_dropout(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_output: str, o_mask: str, ratio: OnnxAttribute):
        attributes = {
            'ratio': ratio,
        }
        return cls([i_data], [o_output, o_mask], None, None, None, attributes, None)


class Cast(Operation):
    """
The operator casts the elements of a given input tensor to a data type
specified by the 'to' argument and returns an output tensor of the same size in
the converted type. The 'to' argument must be one of the data types specified
in the 'DataType' enum field in the TensorProto message.
NOTE: Casting to and from strings is not supported yet.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Cast, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.to = self.attributes.get('to')
        # Input tensor to be cast.
        self.i_input = self.input[0]
        # Output tensor with the same shape as input with type specified by the 'to' argument
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Cast, self).accept(visitor, network)
        visitor.visit_cast(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, to: OnnxAttribute):
        attributes = {
            'to': to,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Gather(Operation):
    """
Given `data` tensor of rank r >= 1, and `indices` tensor of rank q, gather
entries of the axis dimension of `data` (by default outer-most one as axis=0) indexed by `indices`, and concatenates
them in an output tensor of rank q + (r - 1).
Example 1:
  data = [
      [1.0, 1.2],
      [2.3, 3.4],
      [4.5, 5.7],
  ]
  indices = [
      [0, 1],
      [1, 2],
  ]
  output = [
      [
          [1.0, 1.2],
          [2.3, 3.4],
      ],
      [
          [2.3, 3.4],
          [4.5, 5.7],
      ],
  ]
Example 2:
  data = [
      [1.0, 1.2, 1.9],
      [2.3, 3.4, 3.9],
      [4.5, 5.7, 5.9],
  ]
  indices = [
      [0, 2],
  ]
  axis = 1,
  output = [
      [
          [1.0, 1.9],
          [2.3, 3.9],
          [4.5, 5.9],
      ],
  ]
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Gather, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        # Tensor of rank r >= 1.
        self.i_data = self.input[0]
        # Tensor of int32/int64 indices, of any rank q.
        self.i_indices = self.input[1]
        # Tensor of rank q + (r - 1).
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Gather, self).accept(visitor, network)
        visitor.visit_gather(self, network)

    @classmethod
    def create_op(cls, i_data: str, i_indices: str, o_output: str, axis: OnnxAttribute):
        attributes = {
            'axis': axis,
        }
        return cls([i_data, i_indices], [o_output], None, None, None, attributes, None)


class Ceil(Operation):
    """
Ceil takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the ceil is, y = ceil(x), is applied to
the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Ceil, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Ceil, self).accept(visitor, network)
        visitor.visit_ceil(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Concat(Operation):
    """Concatenate a list of tensors into a single tensor    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Concat, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        # List of tensors for concatenation
        # input is variadic [1,infty) just use self.input to access whole list
        # Concatenated tensor
        self.o_concat_result = self.output[0]

    def accept(self, visitor, network):
        super(Concat, self).accept(visitor, network)
        visitor.visit_concat(self, network)

    @classmethod
    def create_op(cls, i_inputs: str, o_concat_result: str, axis: OnnxAttribute):
        attributes = {
            'axis': axis,
        }
        return cls([i_inputs], [o_concat_result], None, None, None, attributes, None)


class Softsign(Operation):
    """
Calculates the softsign (x/(1+|x|)) of the given input tensor element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Softsign, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_input = self.input[0]
        # The softsign (x/(1+|x|)) values of the input tensor computed element-wise
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Softsign, self).accept(visitor, network)
        visitor.visit_softsign(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class ConstantFill(Operation):
    """
The operator fills the elements of the output tensor with a constant value
specified by the 'value' attribute.

The data type is specified by the 'dtype' attribute. The 'dtype' attribute must
be one of the data types specified in the 'DataType' enum field in the
TensorProto message. If the 'dtype' attribute is not provided, the data type of
'value' is used.

The output tensor shape is specified by the 'shape' attribute. If the number of
input is 1, the shape will be identical to that of the input at run time with
optional additional dimensions appended at the end as specified by 'extra_shape'
attribute. In that case the 'shape' attribute should not be set.

If input_as_shape is set to true, then the input should be a 1D tensor
containing the desired output shape (the dimensions specified in extra_shape
will also be appended)

NOTE: Currently, it supports data type of float, int32, int64, and bool.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ConstantFill, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.dtype = self.attributes.get('dtype')
        self.extra_shape = self.attributes.get('extra_shape')
        self.input_as_shape = self.attributes.get('input_as_shape')
        self.shape = self.attributes.get('shape')
        self.value = self.attributes.get('value')
        # Input tensor (optional) to provide shape information.
        # OPTIONAL
        self.i_input = None if len(self.input) < 1 else self.input[0]
        # Output tensor of constant values specified by 'value'argument and its type is specified by the 'dtype' argument
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(ConstantFill, self).accept(visitor, network)
        visitor.visit_constantfill(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, dtype: OnnxAttribute, extra_shape: OnnxAttribute, input_as_shape: OnnxAttribute, shape: OnnxAttribute, value: OnnxAttribute):
        attributes = {
            'dtype': dtype,
            'extra_shape': extra_shape,
            'input_as_shape': input_as_shape,
            'shape': shape,
            'value': value,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Hardmax(Operation):
    """
The operator computes the hardmax (1 for the first maximum value, and 0 for all others) values for each layer in the batch
 of the given input. The input is a 2-D tensor (Tensor<float>) of size
(batch_size x input_feature_dimensions). The output tensor has the same shape
and contains the hardmax values of the corresponding input.

X does not need to explicitly be a 2D vector; rather, it will be
coerced into one. For an arbitrary n-dimensional tensor
X \in [a_0, a_1, ..., a_{k-1}, a_k, ..., a_{n-1}] and k is
the axis provided, then X will be coerced into a 2-dimensional tensor with
dimensions [a_0 * ... * a_{k-1}, a_k * ... * a_{n-1}]. For the default
case where axis=1, this means the X tensor will be coerced into a 2D tensor
of dimensions [a_0, a_1 * ... * a_{n-1}], where a_0 is often the batch size.
In this situation, we must have a_0 = N and a_1 * ... * a_{n-1} = D.
Each of these dimensions must be matched correctly, or else the operator
will throw errors.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Hardmax, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        # The input tensor that's coerced into a 2D matrix of size (NxD) as described above.
        self.i_input = self.input[0]
        # The output values with the same shape as input tensor.
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Hardmax, self).accept(visitor, network)
        visitor.visit_hardmax(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, axis: OnnxAttribute):
        attributes = {
            'axis': axis,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Identity(Operation):
    """Identity operator    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Identity, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_input = self.input[0]
        # Tensor to copy input into.
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Identity, self).accept(visitor, network)
        visitor.visit_identity(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class If(Operation):
    """If conditional    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(If, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.else_branch = self.attributes.get('else_branch')
        self.then_branch = self.attributes.get('then_branch')
        # Condition for the if
        self.i_cond = self.input[0]
        # Values that are live-out to the enclosing scope.
        # output is variadic [1,infty) just use self.output to access whole list

    def accept(self, visitor, network):
        super(If, self).accept(visitor, network)
        visitor.visit_if(self, network)

    @classmethod
    def create_op(cls, i_cond: str, o_outputs: str, else_branch: OnnxAttribute, then_branch: OnnxAttribute):
        attributes = {
            'else_branch': else_branch,
            'then_branch': then_branch,
        }
        return cls([i_cond], [o_outputs], None, None, None, attributes, None)


class ImageScaler(Operation):
    """Scale and bias the input image. Bias values are stored in
the same ordering as the image pixel format.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ImageScaler, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.bias = self.attributes.get('bias')
        self.scale = self.attributes.get('scale')
        # Input tensor of shape [N,C,H,W]
        self.i_input = self.input[0]
        # Result, has same shape and type as input
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(ImageScaler, self).accept(visitor, network)
        visitor.visit_imagescaler(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, bias: OnnxAttribute, scale: OnnxAttribute):
        attributes = {
            'bias': bias,
            'scale': scale,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class RandomUniform(Operation):
    """
Generate a tensor with random values drawn from a uniform distribution. The shape
of the tensor is specified by the `shape` argument and the range by `low` and `high`.

The data type is specified by the 'dtype' argument. The 'dtype' argument must
be one of the data types specified in the 'DataType' enum field in the
TensorProto message.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(RandomUniform, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.dtype = self.attributes.get('dtype')
        self.high = self.attributes.get('high')
        self.low = self.attributes.get('low')
        self.seed = self.attributes.get('seed')
        self.shape = self.attributes.get('shape')
        # Output tensor of random values drawn from uniform distribution
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(RandomUniform, self).accept(visitor, network)
        visitor.visit_randomuniform(self, network)

    @classmethod
    def create_op(cls, o_output: str, dtype: OnnxAttribute, high: OnnxAttribute, low: OnnxAttribute, seed: OnnxAttribute, shape: OnnxAttribute):
        attributes = {
            'dtype': dtype,
            'high': high,
            'low': low,
            'seed': seed,
            'shape': shape,
        }
        return cls([], [o_output], None, None, None, attributes, None)


class Cos(Operation):
    """
Calculates the cosine of the given input tensor, element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Cos, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_input = self.input[0]
        # The cosine of the input tensor computed element-wise
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Cos, self).accept(visitor, network)
        visitor.visit_cos(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Gemm(Operation):
    """General Matrix multiplication:
https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms#Level_3

A' = transpose(A) if transA else A

B' = transpose(B) if transB else B

Compute Y = alpha * A' * B' + beta * C, where input tensor A has shape (M, K) or (K, M),
input tensor B has shape (K, N) or (N, K), input tensor C is broadcastable to shape (M, N),
and output tensor Y has shape (M, N). A will be transposed before doing the
computation if attribute transA is non-zero, same for B and transB.
This operator supports **unidirectional broadcasting** (tensor C should be unidirectional broadcastable to tensor A * B); for more details please check [the doc](Broadcasting.md).    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Gemm, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.alpha = self.attributes.get('alpha')
        self.beta = self.attributes.get('beta')
        self.transA = self.attributes.get('transA')
        self.transB = self.attributes.get('transB')
        # Input tensor A. The shape of A should be (M, K) if transA is 0, or (K, M) if transA is non-zero.
        self.i_A = self.input[0]
        # Input tensor B. The shape of B should be (K, N) if transB is 0, or (N, K) if transB is non-zero.
        self.i_B = self.input[1]
        # Input tensor C. The shape of C should be unidirectional broadcastable to (M, N).
        self.i_C = self.input[2]
        # Output tensor of shape (M, N).
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Gemm, self).accept(visitor, network)
        visitor.visit_gemm(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, i_C: str, o_Y: str, alpha: OnnxAttribute, beta: OnnxAttribute, transA: OnnxAttribute, transB: OnnxAttribute):
        attributes = {
            'alpha': alpha,
            'beta': beta,
            'transA': transA,
            'transB': transB,
        }
        return cls([i_A, i_B, i_C], [o_Y], None, None, None, attributes, None)


class InstanceNormalization(Operation):
    """
Carries out instance normalization as described in the paper
https://arxiv.org/abs/1607.08022.

y = scale * (x - mean) / sqrt(variance + epsilon) + B,
where mean and variance are computed per instance per channel.

    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(InstanceNormalization, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.epsilon = self.attributes.get('epsilon')
        # Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size.
        self.i_input = self.input[0]
        # The input 1-dimensional scale tensor of size C.
        self.i_scale = self.input[1]
        # The input 1-dimensional bias tensor of size C.
        self.i_B = self.input[2]
        # The output tensor of the same shape as input.
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(InstanceNormalization, self).accept(visitor, network)
        visitor.visit_instancenormalization(self, network)

    @classmethod
    def create_op(cls, i_input: str, i_scale: str, i_B: str, o_output: str, epsilon: OnnxAttribute):
        attributes = {
            'epsilon': epsilon,
        }
        return cls([i_input, i_scale, i_B], [o_output], None, None, None, attributes, None)


class Relu(Operation):
    """
Relu takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the rectified linear function, y = max(0, x), is applied to
the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Relu, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Relu, self).accept(visitor, network)
        visitor.visit_relu(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class AveragePool(Operation):
    """
 AveragePool consumes an input tensor X and applies average pooling across the
 the tensor according to kernel sizes, stride sizes, and pad lengths.
 average pooling consisting of computing the average on all values of a
 subset of the input tensor according to the kernel size and downsampling the
 data into the output tensor Y for further processing. The output spatial shape will be following:
 ```
 output_spatial_shape[i] = floor((input_spatial_shape[i] + pad_shape[i] - kernel_spatial_shape[i]) / strides_spatial_shape[i] + 1)

 * pad_shape[i] is sum of pads along axis i
 ```

 `auto_pad` is a DEPRECATED attribute. If you are using them currently, the output spatial shape will be following:
 ```
 VALID: output_spatial_shape[i] = ceil((input_spatial_shape[i] - kernel_spatial_shape[i] + 1) / strides_spatial_shape[i])
 SAME_UPPER or SAME_LOWER: output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides_spatial_shape[i])
 ```
 And pad shape will be following if `SAME_UPPER` or `SAME_LOWER`:
 ```
 pad_shape[i] = (output_spatial_shape[i] - 1) * strides_spatial_shape[i] + kernel_spatial_shape[i] - input_spatial_shape[i]
 ```
 The output of each pooling window is divided by the number of elements (exclude pad when attribute count_include_pad is zero).
     """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(AveragePool, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.auto_pad = self.attributes.get('auto_pad')
        self.count_include_pad = self.attributes.get('count_include_pad')
        self.kernel_shape = self.attributes.get('kernel_shape')
        self.pads = self.attributes.get('pads')
        self.strides = self.attributes.get('strides')
        # Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size. Optionally, if dimension denotation is in effect, the operation expects the input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...].
        self.i_X = self.input[0]
        # Output data tensor from average or max pooling across the input tensor. Dimensions will vary based on various kernel, stride, and pad sizes. Floor value of the dimension is used
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(AveragePool, self).accept(visitor, network)
        visitor.visit_averagepool(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, auto_pad: OnnxAttribute, count_include_pad: OnnxAttribute, kernel_shape: OnnxAttribute, pads: OnnxAttribute, strides: OnnxAttribute):
        attributes = {
            'auto_pad': auto_pad,
            'count_include_pad': count_include_pad,
            'kernel_shape': kernel_shape,
            'pads': pads,
            'strides': strides,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Less(Operation):
    """
Returns the tensor resulted from performing the `less` logical operation
elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting support).

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Less, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # First input operand for the logical operator.
        self.i_A = self.input[0]
        # Second input operand for the logical operator.
        self.i_B = self.input[1]
        # Result tensor.
        self.o_C = self.output[0]

    def accept(self, visitor, network):
        super(Less, self).accept(visitor, network)
        visitor.visit_less(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, o_C: str):
        attributes = {
        }
        return cls([i_A, i_B], [o_C], None, None, None, attributes, None)


class Log(Operation):
    """
Calculates the natural log of the given input tensor, element-wise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Log, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_input = self.input[0]
        # The natural log of the input tensor computed element-wise
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Log, self).accept(visitor, network)
        visitor.visit_log(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class LoopIndexTensor(Operation):
    """This is a special operator only valid inside the loop that supports the common case behavior of accessing the correct element of the input sequence in an RNN. This operator MUST be directly given the passed-in iteration number to the body of a Loop graph. This signals to back-ends that this is a direct indexing operation, with no transforms applied to the index.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(LoopIndexTensor, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axis = self.attributes.get('axis')
        # Tensor to be indexed (has N dimensions)
        self.i_T = self.input[0]
        # Loop index provided as input to the body graph
        self.i_loop_idx = self.input[1]
        # Tensor of N - 1 dims that is a sub tensor of T
        self.o_O = self.output[0]

    def accept(self, visitor, network):
        super(LoopIndexTensor, self).accept(visitor, network)
        visitor.visit_loopindextensor(self, network)

    @classmethod
    def create_op(cls, i_T: str, i_loop_idx: str, o_O: str, axis: OnnxAttribute):
        attributes = {
            'axis': axis,
        }
        return cls([i_T, i_loop_idx], [o_O], None, None, None, attributes, None)


class Floor(Operation):
    """
Floor takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the floor is, y = floor(x), is applied to
the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Floor, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Floor, self).accept(visitor, network)
        visitor.visit_floor(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Min(Operation):
    """
Element-wise min of each of the input tensors. All inputs and outputs must
have the same shape and data type.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Min, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # List of tensors for Min
        # input is variadic [1,infty) just use self.input to access whole list
        # Output tensor. Same dimension as inputs.
        self.o_min = self.output[0]

    def accept(self, visitor, network):
        super(Min, self).accept(visitor, network)
        visitor.visit_min(self, network)

    @classmethod
    def create_op(cls, i_data_0: str, o_min: str):
        attributes = {
        }
        return cls([i_data_0], [o_min], None, None, None, attributes, None)


class RNN(Operation):
    """
Computes an one-layer simple RNN. This operator is usually supported
via some custom implementation such as CuDNN.

Notations:

`X` - input tensor

`i` - input gate

`t` - time step (t-1 means previous time step)

`Wi` - W parameter weight matrix for input gate

`Ri` - R recurrence weight matrix for input gate

`Wbi` - W parameter bias vector for input gate

`Rbi` - R parameter bias vector for input gate

`WBi` - W parameter weight matrix for backward input gate

`RBi` - R recurrence weight matrix for backward input gate

`WBbi` - WR bias vectors for backward input gate

`RBbi` - RR bias vectors for backward input gate

`H` - Hidden state

`num_directions` - 2 if direction == bidirectional else 1

Activation functions:

  Relu(x)                - max(0, x)

  Tanh(x)                - (1 - e^{-2x})/(1 + e^{-2x})

  Sigmoid(x)             - 1/(1 + e^{-x})

  (NOTE: Below are optional)

  Affine(x)              - alpha*x + beta

  LeakyRelu(x)           - x if x >= 0 else alpha * x

  ThresholdedRelu(x)     - x if x >= alpha else 0

  ScaledTanh(x)          - alpha*Tanh(beta*x)

  HardSigmoid(x)         - min(max(alpha*x + beta, 0), 1)

  Elu(x)                 - x if x >= 0 else alpha*(e^x - 1)

  Softsign(x)            - x/(1 + |x|)

  Softplus(x)            - log(1 + e^x)

Equations (Default: f=Tanh):

  - Ht = f(Xt*(Wi^T) + Ht-1*Ri + Wbi + Rbi)
This operator has **optional** inputs/outputs. See [the doc](IR.md) for more details about the representation of optional arguments. An empty string may be used in the place of an actual argument's name to indicate a missing argument. Trailing optional arguments (those not followed by an argument that is present) may also be simply omitted.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(RNN, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.activation_alpha = self.attributes.get('activation_alpha')
        self.activation_beta = self.attributes.get('activation_beta')
        self.activations = self.attributes.get('activations')
        self.clip = self.attributes.get('clip')
        self.direction = self.attributes.get('direction')
        self.hidden_size = self.attributes.get('hidden_size')
        # The input sequences packed (and potentially padded) into one 3-D tensor with the shape of `[seq_length, batch_size, input_size]`.
        self.i_X = self.input[0]
        # The weight tensor for input gate. Concatenation of `Wi` and `WBi` (if bidirectional). The tensor has shape `[num_directions, hidden_size, input_size]`.
        self.i_W = self.input[1]
        # The recurrence weight tensor. Concatenation of `Ri` and `RBi` (if bidirectional). The tensor has shape `[num_directions, hidden_size, hidden_size]`.
        self.i_R = self.input[2]
        # The bias tensor for input gate. Concatenation of `[Wbi, Rbi]` and `[WBbi, RBbi]` (if bidirectional). The tensor has shape `[num_directions, 2*hidden_size]`. Optional: If not specified - assumed to be 0.
        # OPTIONAL
        self.i_B = None if len(self.input) < 4 else self.input[3]
        # Optional tensor specifying lengths of the sequences in a batch. If not specified - assumed all sequences in the batch to have length `seq_length`. It has shape `[batch_size]`.
        # OPTIONAL
        self.i_sequence_lens = None if len(self.input) < 5 else self.input[4]
        # Optional initial value of the hidden. If not specified - assumed to be 0. It has shape `[num_directions, batch_size, hidden_size]`.
        # OPTIONAL
        self.i_initial_h = None if len(self.input) < 6 else self.input[5]
        # A tensor that concats all the intermediate output values of the hidden. It has shape `[seq_length, num_directions, batch_size, hidden_size]`. 
        # OPTIONAL
        self.o_Y = None if len(self.output) < 1 else self.output[0]
        # The last output value of the hidden. It has shape `[num_directions, batch_size, hidden_size]`.
        # OPTIONAL
        self.o_Y_h = None if len(self.output) < 2 else self.output[1]

    def accept(self, visitor, network):
        super(RNN, self).accept(visitor, network)
        visitor.visit_rnn(self, network)

    @classmethod
    def create_op(cls, i_X: str, i_W: str, i_R: str, i_B: str, i_sequence_lens: str, i_initial_h: str, o_Y: str, o_Y_h: str, activation_alpha: OnnxAttribute, activation_beta: OnnxAttribute, activations: OnnxAttribute, clip: OnnxAttribute, direction: OnnxAttribute, hidden_size: OnnxAttribute):
        attributes = {
            'activation_alpha': activation_alpha,
            'activation_beta': activation_beta,
            'activations': activations,
            'clip': clip,
            'direction': direction,
            'hidden_size': hidden_size,
        }
        return cls([i_X, i_W, i_R, i_B, i_sequence_lens, i_initial_h], [o_Y, o_Y_h], None, None, None, attributes, None)


class LpPool(Operation):
    """
 LpPool consumes an input tensor X and applies Lp pooling across the
 the tensor according to kernel sizes, stride sizes, and pad lengths.
 Lp pooling consisting of computing the Lp norm on all values of a subset
 of the input tensor according to the kernel size and downsampling the
 data into the output tensor Y for further processing.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(LpPool, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.auto_pad = self.attributes.get('auto_pad')
        self.kernel_shape = self.attributes.get('kernel_shape')
        self.p = self.attributes.get('p')
        self.pads = self.attributes.get('pads')
        self.strides = self.attributes.get('strides')
        # Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size.
        self.i_X = self.input[0]
        # Output data tensor from Lp pooling across the input tensor. Dimensions will vary based on various kernel, stride, and pad sizes.
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(LpPool, self).accept(visitor, network)
        visitor.visit_lppool(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, auto_pad: OnnxAttribute, kernel_shape: OnnxAttribute, p: OnnxAttribute, pads: OnnxAttribute, strides: OnnxAttribute):
        attributes = {
            'auto_pad': auto_pad,
            'kernel_shape': kernel_shape,
            'p': p,
            'pads': pads,
            'strides': strides,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Max(Operation):
    """
Element-wise max of each of the input tensors. All inputs and outputs must
have the same shape and data type.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Max, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # List of tensors for Max.
        # input is variadic [1,infty) just use self.input to access whole list
        # Output tensor. Same dimension as inputs.
        self.o_max = self.output[0]

    def accept(self, visitor, network):
        super(Max, self).accept(visitor, network)
        visitor.visit_max(self, network)

    @classmethod
    def create_op(cls, i_data_0: str, o_max: str):
        attributes = {
        }
        return cls([i_data_0], [o_max], None, None, None, attributes, None)


class MaxRoiPool(Operation):
    """
 ROI max pool consumes an input tensor X and region of interests (RoIs) to
 apply max pooling across each RoI, to produce output 4-D tensor of shape
 (num_rois, channels, pooled_shape[0], pooled_shape[1]).    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(MaxRoiPool, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.pooled_shape = self.attributes.get('pooled_shape')
        self.spatial_scale = self.attributes.get('spatial_scale')
        # Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data.
        self.i_X = self.input[0]
        # RoIs (Regions of Interest) to pool over. Should be a 2-D tensor of shape (num_rois, 5) given as [[batch_id, x1, y1, x2, y2], ...].
        self.i_rois = self.input[1]
        # RoI pooled output 4-D tensor of shape (num_rois, channels, pooled_shape[0], pooled_shape[1]).
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(MaxRoiPool, self).accept(visitor, network)
        visitor.visit_maxroipool(self, network)

    @classmethod
    def create_op(cls, i_X: str, i_rois: str, o_Y: str, pooled_shape: OnnxAttribute, spatial_scale: OnnxAttribute):
        attributes = {
            'pooled_shape': pooled_shape,
            'spatial_scale': spatial_scale,
        }
        return cls([i_X, i_rois], [o_Y], None, None, None, attributes, None)


class LRN(Operation):
    """
Local Response Normalization proposed in the [AlexNet paper](https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf).
It normalizes over local input regions.
The local region is defined across the channels. For an element X[n, c, d1, ..., dk] in a tensor
of shape (N x C x D1 x D2, ..., Dk), its region is
{X[n, i, d1, ..., dk] | max(0, c - floor((size - 1) / 2)) <= i <= min(C - 1, c + ceil((size - 1) / 2))}.

square_sum[n, c, d1, ..., dk] = sum(X[n, i, d1, ..., dk] ^ 2),
where max(0, c - floor((size - 1) / 2)) <= i <= min(C - 1, c + ceil((size - 1) / 2) - 1).

Y[n, c, d1, ..., dk] = X[n, c, d1, ..., dk] / (bias + alpha / size * square_sum[n, c, d1, ..., dk] ) ^ beta
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(LRN, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.alpha = self.attributes.get('alpha')
        self.beta = self.attributes.get('beta')
        self.bias = self.attributes.get('bias')
        self.size = self.attributes.get('size')
        # Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size. Optionally, if dimension denotation is in effect, the operation expects the input data tensor to arrive with the dimension denotation of [DATA_BATCH, DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...].
        self.i_X = self.input[0]
        # Output tensor, which has the shape and type as input tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(LRN, self).accept(visitor, network)
        visitor.visit_lrn(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, alpha: OnnxAttribute, beta: OnnxAttribute, bias: OnnxAttribute, size: OnnxAttribute):
        attributes = {
            'alpha': alpha,
            'beta': beta,
            'bias': bias,
            'size': size,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Mean(Operation):
    """
Element-wise mean of each of the input tensors. All inputs and outputs must
have the same shape and data type.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Mean, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # List of tensors for Mean.
        # input is variadic [1,infty) just use self.input to access whole list
        # Output tensor. Same dimension as inputs.
        self.o_mean = self.output[0]

    def accept(self, visitor, network):
        super(Mean, self).accept(visitor, network)
        visitor.visit_mean(self, network)

    @classmethod
    def create_op(cls, i_data_0: str, o_mean: str):
        attributes = {
        }
        return cls([i_data_0], [o_mean], None, None, None, attributes, None)


class Mul(Operation):
    """
Performs element-wise binary multiplication (with Numpy-style broadcasting support).

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Mul, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # First operand.
        self.i_A = self.input[0]
        # Second operand.
        self.i_B = self.input[1]
        # Result, has same element type as two inputs
        self.o_C = self.output[0]

    def accept(self, visitor, network):
        super(Mul, self).accept(visitor, network)
        visitor.visit_mul(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, o_C: str):
        attributes = {
        }
        return cls([i_A, i_B], [o_C], None, None, None, attributes, None)


class GlobalMaxPool(Operation):
    """
 GlobalMaxPool consumes an input tensor X and applies max pooling across the
 the values in the same channel. This is equivalent to MaxPool with kernel size
 equal to the spatial dimension of input tensor.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(GlobalMaxPool, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input data tensor from the previous operator; dimensions for image case are (N x C x H x W), where N is the batch size, C is the number of channels, and H and W are the height and the width of the data. For non image case, the dimensions are in the form of (N x C x D1 x D2 ... Dn), where N is the batch size.
        self.i_X = self.input[0]
        # Output data tensor from pooling across the input tensor. Dimensions will be N x C x 1 x 1
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(GlobalMaxPool, self).accept(visitor, network)
        visitor.visit_globalmaxpool(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Pad(Operation):
    """
Given `data` tensor, pads, mode, and value.
Example:
  Insert 0 pads to the beginning of the second dimension.
  data = [
      [1.0, 1.2],
      [2.3, 3.4],
      [4.5, 5.7],
  ]
  pads = [0, 2, 0, 0]
  output = [
      [
          [0.0, 0.0, 1.0, 1.2],
          [0.0, 0.0, 2.3, 3.4],
          [0.0, 0.0, 4.5, 5.7],
      ],
  ]
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Pad, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.mode = self.attributes.get('mode')
        self.pads = self.attributes.get('pads')
        self.value = self.attributes.get('value')
        # Input tensor.
        self.i_data = self.input[0]
        # Tensor after padding.
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Pad, self).accept(visitor, network)
        visitor.visit_pad(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_output: str, mode: OnnxAttribute, pads: OnnxAttribute, value: OnnxAttribute):
        attributes = {
            'mode': mode,
            'pads': pads,
            'value': value,
        }
        return cls([i_data], [o_output], None, None, None, attributes, None)


class Or(Operation):
    """
Returns the tensor resulted from performing the `or` logical operation
elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting support).

This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Or, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # First input operand for the logical operator.
        self.i_A = self.input[0]
        # Second input operand for the logical operator.
        self.i_B = self.input[1]
        # Result tensor.
        self.o_C = self.output[0]

    def accept(self, visitor, network):
        super(Or, self).accept(visitor, network)
        visitor.visit_or(self, network)

    @classmethod
    def create_op(cls, i_A: str, i_B: str, o_C: str):
        attributes = {
        }
        return cls([i_A, i_B], [o_C], None, None, None, attributes, None)


class ReduceL1(Operation):
    """
Computes the L1 norm of the input tensor's element along the provided axes. The resulted
tensor has the same rank as the input if keepdims equal 1. If keepdims equal 0, then
the resulted tensor have the reduced dimension pruned.

The above behavior is similar to numpy, with the exception that numpy default keepdims to
False instead of True.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ReduceL1, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.axes = self.attributes.get('axes')
        self.keepdims = self.attributes.get('keepdims')
        # An input tensor.
        self.i_data = self.input[0]
        # Reduced output tensor.
        self.o_reduced = self.output[0]

    def accept(self, visitor, network):
        super(ReduceL1, self).accept(visitor, network)
        visitor.visit_reducel1(self, network)

    @classmethod
    def create_op(cls, i_data: str, o_reduced: str, axes: OnnxAttribute, keepdims: OnnxAttribute):
        attributes = {
            'axes': axes,
            'keepdims': keepdims,
        }
        return cls([i_data], [o_reduced], None, None, None, attributes, None)


class ParametricSoftplus(Operation):
    """
ParametricSoftplus takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the softplus function, y = alpha * ln(exp(beta * x) + 1), is applied to
the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ParametricSoftplus, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.alpha = self.attributes.get('alpha')
        self.beta = self.attributes.get('beta')
        # 1D input tensor
        self.i_X = self.input[0]
        # 1D input tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(ParametricSoftplus, self).accept(visitor, network)
        visitor.visit_parametricsoftplus(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, alpha: OnnxAttribute, beta: OnnxAttribute):
        attributes = {
            'alpha': alpha,
            'beta': beta,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Pow(Operation):
    """
Pow takes input data (Tensor<T>) and exponent Tensor, and
produces one output data (Tensor<T>) where the function `f(x) = x^exponent`,
is applied to the data tensor elementwise.
This operator supports **multidirectional (i.e., Numpy-style) broadcasting**; for more details please check [the doc](Broadcasting.md).    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Pow, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # First operand, base of the exponent.
        self.i_X = self.input[0]
        # Second operand, power of the exponent.
        self.i_Y = self.input[1]
        # Output tensor (same size as X)
        self.o_Z = self.output[0]

    def accept(self, visitor, network):
        super(Pow, self).accept(visitor, network)
        visitor.visit_pow(self, network)

    @classmethod
    def create_op(cls, i_X: str, i_Y: str, o_Z: str):
        attributes = {
        }
        return cls([i_X, i_Y], [o_Z], None, None, None, attributes, None)


class ATen(Operation):
    """
Experimental allowing ATen operations to be accessed directly from Caffe2
to allow for quick prototyping when ONNX is missing standard versions of
and op    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(ATen, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Arbitrary input
        # input is variadic [1,infty) just use self.input to access whole list
        # Arbitrary output
        # output is variadic [1,infty) just use self.output to access whole list

    def accept(self, visitor, network):
        super(ATen, self).accept(visitor, network)
        visitor.visit_aten(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str):
        attributes = {
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class Constant(Operation):
    """A constant tensor.    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Constant, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.value = self.attributes.get('value')
        # Output tensor containing the same value of the provided tensor.
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Constant, self).accept(visitor, network)
        visitor.visit_constant(self, network)

    @classmethod
    def create_op(cls, o_output: str, value: OnnxAttribute):
        attributes = {
            'value': value,
        }
        return cls([], [o_output], None, None, None, attributes, None)


class RandomNormal(Operation):
    """
Generate a tensor with random values drawn from a normal distribution. The shape
of the tensor is specified by the `shape` argument and the parameter of the normal distribution
specified by `mean` and `scale`.

The data type is specified by the 'dtype' argument. The 'dtype' argument must
be one of the data types specified in the 'DataType' enum field in the
TensorProto message.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(RandomNormal, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.dtype = self.attributes.get('dtype')
        self.mean = self.attributes.get('mean')
        self.scale = self.attributes.get('scale')
        self.seed = self.attributes.get('seed')
        self.shape = self.attributes.get('shape')
        # Output tensor of random values drawn from normal distribution
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(RandomNormal, self).accept(visitor, network)
        visitor.visit_randomnormal(self, network)

    @classmethod
    def create_op(cls, o_output: str, dtype: OnnxAttribute, mean: OnnxAttribute, scale: OnnxAttribute, seed: OnnxAttribute, shape: OnnxAttribute):
        attributes = {
            'dtype': dtype,
            'mean': mean,
            'scale': scale,
            'seed': seed,
            'shape': shape,
        }
        return cls([], [o_output], None, None, None, attributes, None)


class HardSigmoid(Operation):
    """
HardSigmoid takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the HardSigmoid function, y = max(0, min(1, alpha * x + beta)),
is applied to the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(HardSigmoid, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.alpha = self.attributes.get('alpha')
        self.beta = self.attributes.get('beta')
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(HardSigmoid, self).accept(visitor, network)
        visitor.visit_hardsigmoid(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, alpha: OnnxAttribute, beta: OnnxAttribute):
        attributes = {
            'alpha': alpha,
            'beta': beta,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Clip(Operation):
    """
Clip operator limits the given input within an interval. The interval is
specified with arguments 'min' and 'max'. They default to
numeric_limits::lowest() and numeric_limits::max() respectively.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Clip, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.max = self.attributes.get('max')
        self.min = self.attributes.get('min')
        # Input tensor whose elements to be clipped
        self.i_input = self.input[0]
        # Output tensor with clipped input elements
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(Clip, self).accept(visitor, network)
        visitor.visit_clip(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, max: OnnxAttribute, min: OnnxAttribute):
        attributes = {
            'max': max,
            'min': min,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class RandomUniformLike(Operation):
    """
Generate a tensor with random values drawn from a uniform distribution. 
The shape of the output tensor is copied from the shape of the input tensor, 
and the parameters of the uniform distribution are specified by `low` and `high`.

The data type is specified by the 'dtype' argument, or copied from the input tensor if not provided. 
The 'dtype' argument must be one of the data types specified in the 'DataType' enum field in the
TensorProto message and be valid as an output type.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(RandomUniformLike, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.dtype = self.attributes.get('dtype')
        self.high = self.attributes.get('high')
        self.low = self.attributes.get('low')
        self.seed = self.attributes.get('seed')
        # Input tensor to copy shape and optionally type information from.
        self.i_input = self.input[0]
        # Output tensor of random values drawn from uniform distribution
        self.o_output = self.output[0]

    def accept(self, visitor, network):
        super(RandomUniformLike, self).accept(visitor, network)
        visitor.visit_randomuniformlike(self, network)

    @classmethod
    def create_op(cls, i_input: str, o_output: str, dtype: OnnxAttribute, high: OnnxAttribute, low: OnnxAttribute, seed: OnnxAttribute):
        attributes = {
            'dtype': dtype,
            'high': high,
            'low': low,
            'seed': seed,
        }
        return cls([i_input], [o_output], None, None, None, attributes, None)


class LeakyRelu(Operation):
    """
LeakyRelu takes input data (Tensor<T>) and an argument alpha, and produces one
output data (Tensor<T>) where the function `f(x) = alpha * x for x < 0`,
`f(x) = x for x >= 0`, is applied to the data tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(LeakyRelu, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        self.alpha = self.attributes.get('alpha')
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(LeakyRelu, self).accept(visitor, network)
        visitor.visit_leakyrelu(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str, alpha: OnnxAttribute):
        attributes = {
            'alpha': alpha,
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


class Reciprocal(Operation):
    """
Reciprocal takes one input data (Tensor<T>) and produces one output data
(Tensor<T>) where the reciprocal is, y = 1/x, is applied to
the tensor elementwise.
    """

    def __init__(self, input, output, name, op_type, domain, attributes, doc_string):
        super(Reciprocal, self).__init__(input, output, name, op_type, domain, attributes, doc_string)
        # Input tensor
        self.i_X = self.input[0]
        # Output tensor
        self.o_Y = self.output[0]

    def accept(self, visitor, network):
        super(Reciprocal, self).accept(visitor, network)
        visitor.visit_reciprocal(self, network)

    @classmethod
    def create_op(cls, i_X: str, o_Y: str):
        attributes = {
        }
        return cls([i_X], [o_Y], None, None, None, attributes, None)


ONNX_OPERATIONS = {
    'sin': Sin,
    'atan': Atan,
    'asin': Asin,
    'acos': Acos,
    'unsqueeze': Unsqueeze,
    'topk': TopK,
    'tile': Tile,
    'thresholdedrelu': ThresholdedRelu,
    'tanh': Tanh,
    'sum': Sum,
    'squeeze': Squeeze,
    'spacetodepth': SpaceToDepth,
    'softmax': Softmax,
    'slice': Slice,
    'size': Size,
    'shape': Shape,
    'selu': Selu,
    'transpose': Transpose,
    'scaledtanh': ScaledTanh,
    'sigmoid': Sigmoid,
    'scale': Scale,
    'reducesumsquare': ReduceSumSquare,
    'reducesum': ReduceSum,
    'reshape': Reshape,
    'reduceprod': ReduceProd,
    'tan': Tan,
    'globalaveragepool': GlobalAveragePool,
    'reducel2': ReduceL2,
    'meanvariancenormalization': MeanVarianceNormalization,
    'gru': GRU,
    'giventensorfill': GivenTensorFill,
    'multinomial': Multinomial,
    'flatten': Flatten,
    'exp': Exp,
    'equal': Equal,
    'not': Not,
    'sqrt': Sqrt,
    'elu': Elu,
    'reducemin': ReduceMin,
    'div': Div,
    'prelu': PRelu,
    'depthtospace': DepthToSpace,
    'gruunit': GRUUnit,
    'convtranspose': ConvTranspose,
    'logsoftmax': LogSoftmax,
    'reducelogsum': ReduceLogSum,
    'reducemean': ReduceMean,
    'crop': Crop,
    'and': And,
    'reducemax': ReduceMax,
    'argmax': ArgMax,
    'lpnormalization': LpNormalization,
    'loop': Loop,
    'affine': Affine,
    'lstm': LSTM,
    'softplus': Softplus,
    'randomnormallike': RandomNormalLike,
    'argmin': ArgMin,
    'conv': Conv,
    'add': Add,
    'abs': Abs,
    'split': Split,
    'batchnormalization': BatchNormalization,
    'upsample': Upsample,
    'globallppool': GlobalLpPool,
    'reducelogsumexp': ReduceLogSumExp,
    'matmul': MatMul,
    'sub': Sub,
    'maxpool': MaxPool,
    'neg': Neg,
    'xor': Xor,
    'greater': Greater,
    'dropout': Dropout,
    'cast': Cast,
    'gather': Gather,
    'ceil': Ceil,
    'concat': Concat,
    'softsign': Softsign,
    'constantfill': ConstantFill,
    'hardmax': Hardmax,
    'identity': Identity,
    'if': If,
    'imagescaler': ImageScaler,
    'randomuniform': RandomUniform,
    'cos': Cos,
    'gemm': Gemm,
    'instancenormalization': InstanceNormalization,
    'relu': Relu,
    'averagepool': AveragePool,
    'less': Less,
    'log': Log,
    'loopindextensor': LoopIndexTensor,
    'floor': Floor,
    'min': Min,
    'rnn': RNN,
    'lppool': LpPool,
    'max': Max,
    'maxroipool': MaxRoiPool,
    'lrn': LRN,
    'mean': Mean,
    'mul': Mul,
    'globalmaxpool': GlobalMaxPool,
    'pad': Pad,
    'or': Or,
    'reducel1': ReduceL1,
    'parametricsoftplus': ParametricSoftplus,
    'pow': Pow,
    'aten': ATen,
    'constant': Constant,
    'randomnormal': RandomNormal,
    'hardsigmoid': HardSigmoid,
    'clip': Clip,
    'randomuniformlike': RandomUniformLike,
    'leakyrelu': LeakyRelu,
    'reciprocal': Reciprocal,
}